{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Home","text":""},{"location":"#rag2f-documentation-hub","title":"RAG2F Documentation Hub","text":"<p>This repository hosts docs for the rag2f ecosystem.</p> <p>The core idea: rag2f is a plugin-first kernel built around registries + hooks, with optional dependency scope kept in plugins.</p>"},{"location":"#how-the-docs-are-organized","title":"How the docs are organized","text":"<ul> <li>RAG2F covers the core kernel, registries, hooks, and plugin contracts.</li> </ul>"},{"location":"#plugin-list","title":"Plugin list","text":"<ul> <li>rag2f_azure_openai_embedder: Azure OpenAI embedder plugin that uses Spock config.</li> <li>rag2f_macgyver: in-memory plugin for fast local experiments.</li> </ul>"},{"location":"#projects","title":"Projects","text":"<ul> <li>rag2f: the plugin-first kernel for composing RAG systems   \u2192 see the rag2f docs</li> </ul>"},{"location":"#contributing","title":"Contributing","text":"<p>Docs are written in Markdown under <code>mkdocs/</code> and published with MkDocs Material.</p> <ul> <li>Edit or add pages under <code>mkdocs/</code></li> <li>Update <code>mkdocs.yml</code> navigation if you add new pages</li> </ul>"},{"location":"contributing/","title":"Contributing","text":"<p>This page focuses on contributing to the rag2f codebase (core + plugins) in the <code>rag2f-main</code> repo. Docs live in this repo under <code>mkdocs/</code>.</p>"},{"location":"contributing/#repo-layout-at-a-glance","title":"Repo layout at a glance","text":"<ul> <li><code>src/</code>: src-layout package (importable code lives here)</li> <li><code>tests/</code>: pytest suite</li> <li><code>scripts/</code>: release helper scripts</li> <li><code>pyproject.toml</code>: build, Ruff, and pytest config</li> </ul>"},{"location":"contributing/#local-development-workflow","title":"Local development workflow","text":"<p>Minimal setup (venv or Dev Container):</p> <pre><code>python -m venv .venv\nsource .venv/bin/activate\npip install -e '.[dev]'\n</code></pre> <p>Run tests:</p> <pre><code>pytest\n</code></pre> <p>Enable pre-commit hooks (optional, but recommended):</p> <pre><code>pre-commit install\npre-commit run --all-files\n</code></pre>"},{"location":"contributing/#techy-python-rules-ruff","title":"Techy: Python rules (Ruff)","text":"<p>rag2f uses Ruff for linting, import sorting, and formatting. Key settings in <code>rag2f-main/pyproject.toml</code>:</p> <ul> <li>Target version: <code>py312</code></li> <li>Line length: <code>99</code></li> <li>Lint rules: <code>E</code>, <code>F</code>, <code>I</code>, <code>UP</code>, <code>B</code>, <code>SIM</code>, <code>S</code></li> <li><code>E501</code> (line length) is ignored; formatter handles wrapping</li> </ul> <p>Local commands:</p> <pre><code>ruff check src tests\nruff check --fix src tests\nruff format src tests\nruff format --check src tests\n</code></pre>"},{"location":"contributing/#packaging-guardrails","title":"Packaging guardrails","text":"<p>The repo enforces a src-layout build and versioning via <code>setuptools-scm</code>. Expect checks for:</p> <ul> <li><code>dynamic = [\"version\"]</code> in <code>pyproject.toml</code></li> <li><code>setuptools-scm</code> in <code>build-system.requires</code></li> <li><code>local_scheme = \"no-local-version\"</code></li> <li><code>src/rag2f/_version.py</code> generation</li> <li><code>__init__.py</code> in all Python package directories</li> </ul> <p>These are validated in CI and by local scripts.</p>"},{"location":"contributing/#cicd-overview-from-the-current-workflows","title":"CI/CD overview (from the current workflows)","text":"<p>The rag2f repo uses GitHub Actions workflows stored in <code>.github/workflows/</code>:</p>"},{"location":"contributing/#ruffyml","title":"<code>ruff.yml</code>","text":"<ul> <li>Trigger: pushes to <code>main</code>, pull requests</li> <li>Jobs: lint + format check (<code>ruff check</code>, <code>ruff format --check</code>)</li> </ul>"},{"location":"contributing/#ci-dev-testpypiyml","title":"<code>ci-dev-testpypi.yml</code>","text":"<ul> <li>Trigger: pushes and PRs to <code>main</code></li> <li>Jobs:</li> <li>Ruff lint/format</li> <li><code>pip-audit</code> for dependency vulnerabilities</li> <li>pytest (full test run)</li> <li>repo validation (src layout, <code>__init__.py</code>, <code>pyproject.toml</code> checks)</li> <li>build and publish to TestPyPI on <code>main</code> pushes</li> <li>smoke test that installs the TestPyPI artifact and verifies <code>__version__</code></li> </ul> <p>Build versioning uses <code>NEXT_VERSION</code> + <code>SETUPTOOLS_SCM_PRETEND_VERSION_FOR_RAG2F</code>.</p>"},{"location":"contributing/#release-tagsyml","title":"<code>release-tags.yml</code>","text":"<ul> <li>Trigger: tags matching <code>v*</code></li> <li>Checks tag commit is on <code>main</code></li> <li>Builds wheel + sdist, creates checksums</li> <li>Publishes to PyPI</li> <li>Creates a GitHub Release and runs a PyPI install smoke test</li> </ul>"},{"location":"contributing/#local-release-helpers","title":"Local release helpers","text":"<p>The <code>scripts/</code> folder mirrors parts of CI for local checks:</p> <ul> <li><code>scripts/test_release_setup.sh</code>: quick validation of versioning + build artifacts</li> <li><code>scripts/build-local.sh</code>: full local build and install test</li> </ul> <p>These are useful before pushing or tagging a release.</p>"},{"location":"deep_thought/","title":"Deep Thought","text":"<p>Deep Thought is a collection of design notes and experiments around the rag2f kernel. It is intentionally informal and focuses on:</p> <ul> <li>trade-offs and architecture rationale</li> <li>plugin boundaries and contracts</li> <li>future-facing ideas that may or may not land in core</li> </ul> <p>If you are building plugins or debating architecture choices, these notes are a good starting point.</p>"},{"location":"deep_thought/design-notes/","title":"Design notes","text":"<p>This page captures the reasoning behind rag2f design choices.</p>"},{"location":"deep_thought/design-notes/#kernel-boundaries","title":"Kernel boundaries","text":"<p>The core stays deliberately small. When something is volatile or vendor-specific, it belongs in a plugin. This protects the kernel from rapid infrastructure churn.</p>"},{"location":"deep_thought/design-notes/#contracts-over-inheritance","title":"Contracts over inheritance","text":"<p>Protocols and capability checks favor structural typing over deep class hierarchies. This keeps integrations lightweight and reduces the cost of supporting new backends.</p>"},{"location":"deep_thought/design-notes/#pipelines-live-outside-core","title":"Pipelines live outside core","text":"<p>rag2f avoids baking in a single \"retrieve \u2192 rerank \u2192 generate\" flow. Instead, hooks and registries enable multiple pipeline shapes without a monolithic orchestrator.</p>"},{"location":"deep_thought/design-notes/#why-registry-names-are-narrative","title":"Why registry names are narrative","text":"<p>The named components (Spock, Morpheus, OptimusPrime, XFiles, Johnny5) emphasize:</p> <ul> <li>small surface area</li> <li>clear responsibilities</li> <li>minimal coupling</li> </ul> <p>The intent is to prevent a \"god object\" core and to keep extension points explicit.</p>"},{"location":"deep_thought/design-notes/#open-questions","title":"Open questions","text":"<p>Topics still being explored:</p> <ul> <li>How to express multi-tenant configuration without leaking tenant state into the kernel.</li> <li>Where to draw the line between hooks and higher-level workflow engines.</li> <li>Best practices for plugin dependency isolation at scale.</li> </ul>"},{"location":"rag2f/","title":"rag2f overview","text":"<p>rag2f (short for \"rag to the future\") is a plugin-first, entry-point\u2013driven kernel for composing Retrieval-Augmented Generation (RAG) systems without forcing a single pipeline shape.</p> <pre><code>flowchart LR\n    subgraph CORE[\"Kernel (stable)\"]\n        S[Spock] --&gt; M[Morpheus]\n        M --&gt; OP[OptimusPrime]\n        M --&gt; XF[XFiles]\n    end\n\n    subgraph PLUGINS[\"Plugins (volatile)\"]\n        E[Embedders]\n        R[Repositories]\n        H[Hooks]\n    end\n\n    PLUGINS --&gt; M\n\n    APP[Your App] --&gt; CORE</code></pre> <p>rag2f is not a turnkey RAG pipeline. Pipelines live in plugins or in your application.</p>"},{"location":"rag2f/#the-problem-it-solves","title":"The problem it solves","text":"<p>RAG stacks depend on fast-moving infrastructure (vector DBs, LLM SDKs, hosted services). That creates two recurring problems:</p> <ul> <li>Supply-chain risk: dependency churn breaks builds, increases attack surface, and forces migrations.</li> <li>Architecture rigidity: \u201cone pipeline to rule them all\u201d hides backend-specific power and makes swaps painful.</li> </ul> <p>rag2f addresses both by: - keeping the base install lean, - pushing integrations into plugins with scoped dependencies, - using explicit contracts (protocols) and capability declarations.</p>"},{"location":"rag2f/#why-rag2f","title":"Why rag2f","text":"<p>The kernel stays intentionally small so you can evolve your stack safely. In practice, this means:</p> <ul> <li>plugins own their dependencies instead of ballooning the core,</li> <li>registries give you a stable surface area for embedders and repositories,</li> <li>hooks let plugins compose behavior without a forced pipeline shape.</li> </ul>"},{"location":"rag2f/#design-goals","title":"Design goals","text":"<ul> <li>Small, stable core: registries + hooks only, no opinionated pipeline.</li> <li>Volatile edges: backends and SDKs live in plugins, not the kernel.</li> <li>Explicit contracts: protocols and capabilities make features clear.</li> <li>Instance isolation: each RAG2F instance has its own config and registries.</li> <li>Deterministic discovery: entry-point plugins override filesystem plugins.</li> </ul>"},{"location":"rag2f/#when-rag2f-is-a-good-fit","title":"When rag2f is a good fit","text":"<p>Use rag2f when you need: - multiple storage backends or embedding providers, - a pluggable architecture with strict boundaries, - a core you can keep stable while integrations evolve.</p> <p>rag2f may not be a fit when you want a single, fixed pipeline with all decisions pre-made.</p>"},{"location":"rag2f/#what-you-get-in-core","title":"What you get in core","text":"<p>A <code>RAG2F</code> instance wires together a few intentionally-named components:</p> <ul> <li>Spock: configuration manager (JSON + env; env overrides JSON)</li> <li>Morpheus: plugin &amp; hook manager (entry points + filesystem)</li> <li>OptimusPrime: embedder registry (embedders contributed by plugins)</li> <li>XFiles: repository registry (SQL/vector/graph/document repositories)</li> <li>Johnny5: input manager (small deterministic pre-processing)</li> </ul>"},{"location":"rag2f/#registries-hooks-mental-model","title":"Registries + hooks (mental model)","text":"<p>rag2f is easiest to reason about as registries + hooks:</p> <ul> <li>Registries store validated implementations (embedders, repositories).</li> <li>Hooks let plugins contribute those implementations (and compose behavior).</li> <li>The core stays stable while plugins evolve independently.</li> </ul>"},{"location":"rag2f/#plugin-discovery-model","title":"Plugin discovery model","text":"<p>Plugins are discovered in two places (in precedence order):</p> <ol> <li>Entry points (<code>rag2f.plugins</code>) for installed packages</li> <li>Filesystem plugins (local development in <code>./plugins</code>)</li> </ol> <p>Entry points win over filesystem to avoid ambiguity in production.</p>"},{"location":"rag2f/#the-typical-lifecycle","title":"The typical lifecycle","text":"<ol> <li>Load configuration (Spock) and validate basics.</li> <li>Discover plugins (Morpheus) from entry points and local folders.</li> <li>Register capabilities (embedders, repositories, hooks).</li> <li>Compose a pipeline in your app or via plugin hooks.</li> <li>Execute RAG workflows using the registries and hooks.</li> </ol> <p>This keeps the kernel stable while allowing your stack to evolve.</p>"},{"location":"rag2f/#how-to-extend-safely","title":"How to extend safely","text":"<ul> <li>Add embedders and repositories via plugins.</li> <li>Keep plugin dependencies scoped to the plugin folder.</li> <li>Use hooks for behavior composition; keep core untouched.</li> </ul>"},{"location":"rag2f/#quick-links","title":"Quick links","text":"Getting Started Core Concepts Reference Quickstart Concepts Hooks Reference Installation Architecture Result Pattern Configuration Plugins Troubleshooting Hooks Embedders Repositories"},{"location":"rag2f/#license","title":"License","text":"<p>rag2f is distributed under GPL-3.0 (see the repository\u2019s <code>LICENSE</code>).</p>"},{"location":"rag2f/#get-in-touch","title":"Get in touch","text":"<p>If you\u2019re working on rag2f plugins or want to align on architecture, open a GitHub issue/discussion in the rag2f repo.</p>"},{"location":"rag2f/architecture/","title":"Architecture","text":"<p>rag2f is a kernel: it gives you the smallest stable set of components needed to compose RAG systems.</p> <p>Everything volatile lives outside the core \u2014 in plugins or your application.</p>"},{"location":"rag2f/architecture/#system-overview","title":"System Overview","text":"<pre><code>flowchart TB\n    subgraph APP[\"Your Application\"]\n        A[App Code]\n    end\n\n    subgraph RAG2F[\"RAG2F Kernel\"]\n        S[Spock&lt;br/&gt;config]\n        M[Morpheus&lt;br/&gt;plugins/hooks]\n        J[Johnny5&lt;br/&gt;input]\n        I[IndianaJones&lt;br/&gt;retrieval]\n        OP[OptimusPrime&lt;br/&gt;embedders]\n        XF[XFiles&lt;br/&gt;repositories]\n\n        S --&gt; M\n        M --&gt; J\n        M --&gt; I\n        M --&gt; OP\n        M --&gt; XF\n    end\n\n    subgraph PLUGINS[\"Plugins\"]\n        P1[Embedder Plugin]\n        P2[Repository Plugin]\n        P3[Custom Hooks]\n    end\n\n    A --&gt; RAG2F\n    PLUGINS --&gt; M</code></pre> <p>Design Note: The kernel stays small and stable. All volatile code (embedders, repositories, custom logic) lives in plugins, not core.</p>"},{"location":"rag2f/architecture/#high-level-diagram","title":"High-level diagram","text":"<pre><code>               +-----------------------+\n               |   Your Application    |\n               +-----------+-----------+\n                           |\n                        RAG2F\n                           |\n        +------------------+------------------+\n        |                  |                  |\n      Spock             Morpheus          Johnny5\n (config manager)   (plugins &amp; hooks)  (input manager)\n        |                  |\n        |            +-----+--------------------------+\n        |            |                                |\n   OptimusPrime    entry points                  filesystem\n (embedder registry) (rag2f.plugins)             ./plugins\n        |\n      XFiles\n (repository registry)\n</code></pre>"},{"location":"rag2f/architecture/#what-lives-in-core-vs-plugins","title":"What lives in core vs plugins","text":""},{"location":"rag2f/architecture/#core-stable","title":"Core (stable)","text":"<ul> <li>configuration loader &amp; merger (Spock)</li> <li>plugin discovery and hook orchestration (Morpheus)</li> <li>registries (OptimusPrime, XFiles)</li> <li>protocols/contracts and validation</li> </ul>"},{"location":"rag2f/architecture/#plugins-volatile","title":"Plugins (volatile)","text":"<ul> <li>embedders (Azure OpenAI, OpenAI, local models, etc.)</li> <li>repositories (Postgres, SQLite, Qdrant, Pinecone, Neo4j, etc.)</li> <li>orchestration patterns (pipelines, workers, DAGs)</li> <li>application-specific behavior via hooks</li> </ul> <p>Plugins can ship their own dependencies so the kernel stays minimal and stable.</p>"},{"location":"rag2f/architecture/#naming-is-intentional","title":"Naming is intentional","text":"<p>The narrative names are constraints on design:</p> <ul> <li>registries/managers should stay small and predictable</li> <li>executors/orchestrators should live outside the kernel</li> </ul> <p>This helps prevent a \u201cgod object\u201d core.</p>"},{"location":"rag2f/architecture/#pipeline-philosophy","title":"Pipeline philosophy","text":"<p>rag2f does not impose a single \u201cretrieve \u2192 rerank \u2192 generate\u201d pipeline. Instead, you build pipelines by composing: - hooks - registries (get the embedder/repository you need) - your own application code</p>"},{"location":"rag2f/architecture/#startup-sequence","title":"Startup sequence","text":"<pre><code>sequenceDiagram\n    participant App\n    participant RAG2F\n    participant Spock\n    participant Morpheus\n    participant Plugin\n\n    App-&gt;&gt;RAG2F: await RAG2F.create()\n    RAG2F-&gt;&gt;Spock: load config (JSON + env)\n    RAG2F-&gt;&gt;Morpheus: find_plugins()\n    Morpheus-&gt;&gt;Plugin: scan entry points\n    Morpheus-&gt;&gt;Plugin: scan filesystem\n    Plugin-&gt;&gt;Morpheus: @plugin activated()\n    Plugin-&gt;&gt;Morpheus: register @hook functions\n    Morpheus-&gt;&gt;RAG2F: ready\n    RAG2F-&gt;&gt;App: instance</code></pre> <p>A typical startup flow:</p> <ol> <li>Spock loads configuration from JSON + env (env wins).</li> <li>Morpheus discovers plugins (entry points, then filesystem).</li> <li>Plugins register hooks and contribute embedders/repositories.</li> <li>Registries validate implementations and enforce contracts.</li> <li>Your app composes a pipeline with hooks and registry lookups.</li> </ol>"},{"location":"rag2f/architecture/#data-flow-conceptual","title":"Data flow (conceptual)","text":"<pre><code>flowchart LR\n    Input[User Input] --&gt; J5[Johnny5]\n    J5 --&gt; |hooks| Embed[OptimusPrime]\n    Embed --&gt; Store[XFiles]\n\n    Query[Query] --&gt; IJ[IndianaJones]\n    IJ --&gt; |retrieve hook| Search[Vector Search]\n    Search --&gt; |search hook| Response[Response]</code></pre> <p>Johnny5 accepts input, then Morpheus runs the hook pipeline. The pipeline uses registries to fetch embedders or repositories as needed.</p>"},{"location":"rag2f/architecture/#core-vs-plugins","title":"Core vs Plugins","text":"Core (stable) Plugins (volatile) Spock (config) Embedders (Azure, OpenAI, local) Morpheus (plugins/hooks) Repositories (Qdrant, Postgres, etc.) OptimusPrime (registry) Custom pipelines XFiles (registry) App-specific hooks Johnny5 (input) IndianaJones (retrieval)"},{"location":"rag2f/architecture/#extension-points","title":"Extension points","text":"<p>Where you can extend rag2f safely:</p> <ul> <li>Plugins: add embedders and repositories without touching core.</li> <li>Hooks: compose multi-step pipelines (preprocess, retrieve, rerank, generate).</li> <li>Native handles: drop down to backend SDKs when needed.</li> </ul>"},{"location":"rag2f/architecture/#dependency-isolation","title":"Dependency isolation","text":"<p>Core dependencies are intentionally minimal. Heavy SDKs live in plugins, which means:</p> <ul> <li>faster base installs,</li> <li>smaller attack surface,</li> <li>backend-specific upgrades that do not destabilize the kernel.</li> </ul>"},{"location":"rag2f/architecture/#runtime-boundaries","title":"Runtime boundaries","text":"<p>The core does not:</p> <ul> <li>enforce a specific prompt format,</li> <li>provide a fixed agent loop,</li> <li>assume a specific vector database or LLM provider.</li> </ul> <p>This keeps the kernel stable and lets you build opinionated workflows in plugins or app code.</p>"},{"location":"rag2f/concepts/","title":"Concepts","text":"<p>This page defines the core terms used throughout the rag2f docs.</p> <pre><code>flowchart LR\n    Create[RAG2F.create]\n    Spock[Load config]\n    Morpheus[Discover plugins]\n    Hooks[Register hooks]\n    Ready[Instance ready]\n\n    Create --&gt; Spock\n    Spock --&gt; Morpheus\n    Morpheus --&gt; Hooks\n    Hooks --&gt; Ready</code></pre> <p>Design Note: The sequence is linear and deterministic: config \u2192 discovery \u2192 registration. This allows plugins to access config during <code>activated()</code> and ensures all resources are ready before use.</p>"},{"location":"rag2f/concepts/#kernel","title":"Kernel","text":"<p>The kernel is the small, stable core of rag2f. It only contains:</p> <ul> <li>configuration and plugin discovery</li> <li>registries and contracts</li> <li>hook orchestration</li> </ul> <p>Everything else should live in plugins or your application.</p>"},{"location":"rag2f/concepts/#instance","title":"Instance","text":"<p>An instance is a single <code>RAG2F</code> object with its own configuration, registries, and plugin state. Instances are intentionally isolated so tests, tenants, or apps can run side by side without cross-talk.</p>"},{"location":"rag2f/concepts/#plugin","title":"Plugin","text":"<p>A plugin is a self-contained integration that contributes hooks, embedders, repositories, or helpers. Plugins are discovered via Python entry points or a local <code>plugins/</code> folder.</p>"},{"location":"rag2f/concepts/#plugin-id","title":"Plugin ID","text":"<p>A plugin ID is the stable identifier used for namespacing config and avoiding collisions. It also becomes the namespace used in logs and hook registrations.</p>"},{"location":"rag2f/concepts/#hook","title":"Hook","text":"<p>A hook is a named pipeline stage. Multiple hooks can register for the same stage and are executed in priority order. Hooks optionally receive a pipeable payload called <code>phone</code> that flows through the pipeline.</p>"},{"location":"rag2f/concepts/#phone","title":"Phone","text":"<p>Phone is the pipeable payload that moves through a hook pipeline. It is typically a small dict or dataclass that each hook can enrich.</p>"},{"location":"rag2f/concepts/#registry","title":"Registry","text":"<p>Registries are named stores owned by the kernel:</p> <ul> <li>OptimusPrime stores embedders.</li> <li>XFiles stores repositories.</li> </ul> <p>Registries enforce basic contracts and protect against accidental overrides.</p>"},{"location":"rag2f/concepts/#protocol","title":"Protocol","text":"<p>A protocol is a minimal interface a plugin component must satisfy. rag2f uses protocols to validate embedders and repositories without prescribing full implementations.</p>"},{"location":"rag2f/concepts/#capability","title":"Capability","text":"<p>A capability is a feature flag declared by a repository to signal which operations it supports. This protects callers from invoking methods the backend does not implement.</p>"},{"location":"rag2f/concepts/#entry-point","title":"Entry point","text":"<p>An entry point is a packaging-time registration that lets Morpheus discover a plugin from installed packages. Entry points are resolved before filesystem plugins to keep discovery deterministic.</p>"},{"location":"rag2f/concepts/#native-escape-hatch","title":"Native escape hatch","text":"<p>The native escape hatch is a repository feature that exposes a backend-specific handle so you can access vendor-specific power without distorting the core contracts.</p>"},{"location":"rag2f/concepts/#pipeline","title":"Pipeline","text":"<p>A pipeline is the ordered composition of hooks and application logic that turns a user input into a response. rag2f does not define a default pipeline; you assemble one explicitly.</p>"},{"location":"rag2f/concepts/#result-pattern","title":"Result pattern","text":"<p>The Result pattern returns structured outcomes for expected states (empty input, missing repo, no results) instead of raising exceptions. See Result pattern for details and examples.</p>"},{"location":"rag2f/configuration/","title":"Configuration (Spock)","text":"<p>Spock is the centralized configuration system for rag2f.</p> <pre><code>flowchart LR\n    subgraph Sources\n        ENV[Environment Variables]\n        JSON[config.json]\n        DICT[config dict]\n        DEF[Defaults]\n    end\n\n    ENV --&gt; Spock\n    JSON --&gt; Spock\n    DICT --&gt; Spock\n    DEF --&gt; Spock\n\n    Spock --&gt; |\"get('rag2f.*')\"| Core\n    Spock --&gt; |\"get('plugins.*')\"| Plugins</code></pre>"},{"location":"rag2f/configuration/#precedence","title":"Precedence","text":"Priority Source Use Case 1 (highest) Environment Secrets, per-env overrides 2 JSON file Project settings 3 Config dict Programmatic defaults 4 Defaults Fallback values"},{"location":"rag2f/configuration/#environment-variables","title":"Environment Variables","text":"<p>Naming: <code>RAG2F__&lt;SECTION&gt;__&lt;KEY&gt;__&lt;SUBKEY&gt;</code></p> Example Overrides <code>RAG2F__RAG2F__EMBEDDER_DEFAULT=azure</code> <code>rag2f.embedder_default</code> <code>RAG2F__PLUGINS__MY_PLUGIN__API_KEY=xxx</code> <code>plugins.my_plugin.api_key</code> <p>Type inference: <code>true/false</code> \u2192 bool, numbers \u2192 int/float, JSON strings \u2192 parsed</p>"},{"location":"rag2f/configuration/#config-file","title":"Config File","text":"MinimalWith Plugin <pre><code>{\n  \"rag2f\": {\n    \"embedder_default\": \"test_embedder\"\n  }\n}\n</code></pre> <pre><code>{\n  \"rag2f\": {\n    \"embedder_default\": \"azure_openai_embedder\"\n  },\n  \"plugins\": {\n    \"azure_openai_embedder\": {\n      \"azure_endpoint\": \"https://your.openai.azure.com\",\n      \"deployment\": \"text-embedding-ada-002\"\n    }\n  }\n}\n</code></pre>"},{"location":"rag2f/configuration/#loading","title":"Loading","text":"<pre><code># From file\nrag2f = await RAG2F.create(config_path=\"config.json\")\n\n# From dict\nrag2f = await RAG2F.create(config={\"rag2f\": {\"embedder_default\": \"test\"}})\n</code></pre>"},{"location":"rag2f/configuration/#accessing-config","title":"Accessing Config","text":"Core SettingsPlugin Settings <pre><code># Typed helper\nembedder = rag2f.spock.get_rag2f_config(\"embedder_default\")\n\n# Direct path\nvalue = rag2f.spock.get(\"rag2f.embedder_default\")\n</code></pre> <pre><code># Get entire plugin config\ncfg = rag2f.spock.get_plugin_config(\"azure_openai_embedder\")\napi_key = cfg.get(\"api_key\")\n\n# Direct path\nkey = rag2f.spock.get(\"plugins.azure_openai_embedder.api_key\")\n</code></pre>"},{"location":"rag2f/configuration/#best-practices","title":"Best Practices","text":"Do Don't Secrets in env vars Secrets in config.json Plugin config under <code>plugins.&lt;id&gt;</code> Flat plugin config Fail fast on missing required Silent fallback"},{"location":"rag2f/configuration/#troubleshooting","title":"Troubleshooting","text":"<pre><code>rag2f.spock.is_loaded      # True if config loaded\nrag2f.spock.config_path    # Path to loaded file\n</code></pre>"},{"location":"rag2f/embedders/","title":"Embedders (OptimusPrime)","text":"<p>OptimusPrime is the embedder registry. Embedders are contributed by plugins and must satisfy the <code>Embedder</code> protocol.</p>"},{"location":"rag2f/embedders/#registration-flow","title":"Registration Flow","text":"<pre><code>sequenceDiagram\n    participant Plugin\n    participant Morpheus\n    participant OP as OptimusPrime\n\n    Plugin-&gt;&gt;Morpheus: @hook rag2f_bootstrap_embedders\n    Morpheus-&gt;&gt;Plugin: execute hook\n    Plugin-&gt;&gt;OP: register(\"name\", embedder)\n    OP-&gt;&gt;OP: validate protocol\n    OP--&gt;&gt;Plugin: registered</code></pre>"},{"location":"rag2f/embedders/#the-embedder-protocol","title":"The <code>Embedder</code> Protocol","text":"<pre><code>class Embedder(Protocol):\n    @property\n    def size(self) -&gt; int:\n        \"\"\"Vector dimension (e.g., 1536).\"\"\"\n        ...\n\n    def getEmbedding(self, text: str, *, normalize: bool = False) -&gt; list[float]:\n        \"\"\"Return embedding vector.\"\"\"\n        ...\n</code></pre>"},{"location":"rag2f/embedders/#quick-example","title":"Quick Example","text":"<pre><code># In your plugin hooks.py\n@hook(\"rag2f_bootstrap_embedders\", priority=10)\ndef register_embedder(*, rag2f):\n    config = rag2f.spock.get_plugin_config(\"my_embedder\")\n    rag2f.optimus_prime.register(\"my_embedder\", MyEmbedder(config))\n\n# In your app\nembedder = rag2f.optimus_prime.get_default()\nvector = embedder.getEmbedding(\"hello world\")\n</code></pre>"},{"location":"rag2f/embedders/#api-reference","title":"API Reference","text":"Method Description <code>register(key, embedder)</code> Register embedder (validates protocol) <code>get(key)</code> Get by key (or <code>None</code>) <code>get_default()</code> Get default (config: <code>rag2f.embedder_default</code>) <code>has(key)</code> Check existence <code>list_keys()</code> List all registered <code>unregister(key)</code> Remove embedder"},{"location":"rag2f/embedders/#override-policy","title":"Override Policy","text":"<ul> <li>Same instance + same key \u2192 OK (idempotent)</li> <li>Different instance + existing key \u2192 <code>ValueError</code></li> </ul>"},{"location":"rag2f/embedders/#default-selection","title":"Default Selection","text":"<ol> <li>Single embedder \u2192 automatic default</li> <li>Multiple \u2192 requires <code>rag2f.embedder_default</code> in config</li> <li>No embedders \u2192 <code>LookupError</code></li> </ol>"},{"location":"rag2f/hooks-reference/","title":"Hooks Reference","text":"<p>Complete reference of all available hooks with signatures and examples.</p>"},{"location":"rag2f/hooks-reference/#available-hooks-by-module","title":"Available Hooks by Module","text":"\ud83d\ude80 Bootstrap\ud83d\udce5 Johnny5 (Input)\ud83d\udd0d IndianaJones (Retrieval) Hook Purpose <code>rag2f_bootstrap_embedders</code> Register embedders/repos at startup Hook Purpose <code>get_id_input_text</code> Generate ID for input <code>check_duplicated_input_text</code> Check if duplicate <code>handle_text_foreground</code> Process/store input Hook Purpose <code>indiana_jones_retrieve</code> Vector retrieval <code>indiana_jones_search</code> Search + synthesis"},{"location":"rag2f/hooks-reference/#hook-flow-overview","title":"Hook Flow Overview","text":"<pre><code>flowchart TB\n    subgraph BOOTSTRAP[\"\ud83d\ude80 Bootstrap Phase\"]\n        B1[rag2f_bootstrap_embedders]\n    end\n\n    subgraph JOHNNY5[\"\ud83d\udce5 Johnny5 - Input Processing\"]\n        J1[get_id_input_text]\n        J2[check_duplicated_input_text]\n        J3[handle_text_foreground]\n        J1 --&gt; J2 --&gt; J3\n    end\n\n    subgraph INDIANA[\"\ud83d\udd0d IndianaJones - Retrieval\"]\n        I1[indiana_jones_retrieve]\n        I2[indiana_jones_search]\n    end\n\n    BOOTSTRAP --&gt; JOHNNY5\n    JOHNNY5 --&gt; INDIANA</code></pre> <p>Design Note: Hooks follow a clear execution order. Bootstrap hooks run once at startup, Johnny5 hooks process each input, and IndianaJones hooks handle retrieval queries. Each hook can be overridden by registering a higher-priority implementation.</p>"},{"location":"rag2f/hooks-reference/#bootstrap-hooks","title":"Bootstrap Hooks","text":""},{"location":"rag2f/hooks-reference/#rag2f_bootstrap_embedders","title":"<code>rag2f_bootstrap_embedders</code>","text":"<p>Called once during <code>RAG2F.create()</code> to register embedders and repositories.</p> Property Value Module OptimusPrime Piped No Signature <code>(*, rag2f)</code> Default Priority N/A (no default) <pre><code>@hook(\"rag2f_bootstrap_embedders\", priority=10)\ndef register_embedder(*, rag2f):\n    \"\"\"Register embedder during bootstrap.\"\"\"\n    config = rag2f.spock.get_plugin_config(\"my_plugin\")\n\n    # Validate config\n    if not config.get(\"api_key\"):\n        raise ValueError(\"api_key required\")\n\n    embedder = MyEmbedder(api_key=config[\"api_key\"])\n    rag2f.optimus_prime.register(\"my_embedder\", embedder)\n\n    # Can also register repositories\n    rag2f.xfiles.execute_register(\"my_repo\", MyRepo())\n</code></pre>"},{"location":"rag2f/hooks-reference/#johnny5-hooks-input-processing","title":"Johnny5 Hooks (Input Processing)","text":""},{"location":"rag2f/hooks-reference/#get_id_input_text","title":"<code>get_id_input_text</code>","text":"<p>Generate or retrieve a unique ID for incoming text.</p> Property Value Module Johnny5 Piped Yes (<code>track_id: str</code>) Signature <code>(track_id, text, *, rag2f)</code> Default UUID if no hook returns a value <p>Override example:</p> <pre><code>@hook(\"get_id_input_text\", priority=10)\ndef custom_id(track_id, text, *, rag2f):\n    \"\"\"Generate custom ID based on content hash.\"\"\"\n    import hashlib\n    return hashlib.sha256(text.encode()).hexdigest()[:16]\n</code></pre> <p>Use default ID:</p> <pre><code>@hook(\"get_id_input_text\", priority=5)\ndef maybe_custom_id(track_id, text, *, rag2f):\n    \"\"\"Only override for specific cases.\"\"\"\n    if text.startswith(\"SPECIAL:\"):\n        return f\"special-{track_id}\"\n    return track_id  # Use existing/default ID\n</code></pre>"},{"location":"rag2f/hooks-reference/#check_duplicated_input_text","title":"<code>check_duplicated_input_text</code>","text":"<p>Check if input has already been processed.</p> Property Value Module Johnny5 Piped Yes (<code>is_dup: bool</code>) Signature <code>(is_dup, track_id, text, *, rag2f)</code> Default <code>False</code> (no duplicate check) <pre><code>@hook(\"check_duplicated_input_text\", priority=10)\ndef check_duplicate(is_dup, track_id, text, *, rag2f):\n    \"\"\"Check against stored IDs.\"\"\"\n    if is_dup:\n        return is_dup  # Already flagged by higher-priority hook\n\n    repo_result = rag2f.xfiles.execute_get(\"processed_ids\")\n    if repo_result.is_ok() and repo_result.repository:\n        return repo_result.repository.exists(track_id)\n\n    return False\n</code></pre>"},{"location":"rag2f/hooks-reference/#handle_text_foreground","title":"<code>handle_text_foreground</code>","text":"<p>Main input processing hook. This is where you store, embed, or index text.</p> Property Value Module Johnny5 Piped Yes (<code>done: bool</code>) Signature <code>(done, track_id, text, *, rag2f)</code> Default <code>NOT_HANDLED</code> if no hook returns <code>True</code> <p>The <code>done</code> Pattern</p> <p>Always check <code>done</code> first. If <code>True</code>, a higher-priority hook already processed this input.</p> <p>Basic implementation:</p> <pre><code>@hook(\"handle_text_foreground\", priority=10)\ndef store_text(done, track_id, text, *, rag2f):\n    \"\"\"Store text in vector DB.\"\"\"\n    if done:\n        return done  # Already handled\n\n    # Get embedder and repository\n    embedder = rag2f.optimus_prime.get_default()\n    repo_result = rag2f.xfiles.execute_get(\"vectors\")\n\n    if not repo_result.is_ok() or not repo_result.repository:\n        return False  # Let other hooks try\n\n    # Embed and store\n    vector = embedder.getEmbedding(text)\n    repo_result.repository.insert(track_id, vector, {\"text\": text})\n\n    return True  # Mark as handled\n</code></pre> <p>Override default processing:</p> <pre><code>@hook(\"handle_text_foreground\", priority=100)\ndef my_custom_processor(done, track_id, text, *, rag2f):\n    \"\"\"Override default - runs FIRST due to priority 100.\"\"\"\n    if done:\n        return done\n\n    # Your completely custom processing\n    custom_pipeline(track_id, text)\n\n    return True  # Prevents default hook from running\n</code></pre> <p>Conditional processing:</p> <pre><code>@hook(\"handle_text_foreground\", priority=50)\ndef selective_processor(done, track_id, text, *, rag2f):\n    \"\"\"Only process certain inputs.\"\"\"\n    if done:\n        return done\n\n    # Only handle specific inputs\n    if not text.startswith(\"PROCESS:\"):\n        return False  # Let other hooks handle\n\n    process_special(track_id, text)\n    return True\n</code></pre>"},{"location":"rag2f/hooks-reference/#indianajones-hooks-retrieval","title":"IndianaJones Hooks (Retrieval)","text":""},{"location":"rag2f/hooks-reference/#indiana_jones_retrieve","title":"<code>indiana_jones_retrieve</code>","text":"<p>Transform or implement retrieval logic.</p> Property Value Module IndianaJones Piped Yes (<code>result: RetrieveResult</code>) Signature <code>(result, query, k, *, rag2f)</code> Default Empty result if no hook implements <pre><code>from rag2f.core.dto.indiana_jones_dto import RetrieveResult, RetrievedItem\n\n@hook(\"indiana_jones_retrieve\", priority=10)\ndef vector_retrieval(result, query, k, *, rag2f):\n    \"\"\"Implement vector search retrieval.\"\"\"\n    embedder = rag2f.optimus_prime.get_default()\n    repo_result = rag2f.xfiles.execute_get(\"vectors\")\n\n    if not repo_result.is_ok():\n        return result  # Pass through\n\n    # Embed query and search\n    query_vec = embedder.getEmbedding(query)\n    results = repo_result.repository.vector_search(query_vec, k)\n\n    items = [\n        RetrievedItem(\n            id=r[\"id\"],\n            text=r.get(\"text\", \"\"),\n            score=r.get(\"score\"),\n            metadata=r.get(\"metadata\", {})\n        )\n        for r in results\n    ]\n\n    return RetrieveResult.success(query=query, items=items)\n</code></pre> <p>Override retrieval:</p> <pre><code>@hook(\"indiana_jones_retrieve\", priority=100)\ndef my_retrieval(result, query, k, *, rag2f):\n    \"\"\"Override default retrieval completely.\"\"\"\n    # Your custom retrieval logic\n    items = my_custom_search(query, k)\n    return RetrieveResult.success(query=query, items=items)\n</code></pre>"},{"location":"rag2f/hooks-reference/#indiana_jones_search","title":"<code>indiana_jones_search</code>","text":"<p>Transform or implement search (retrieve + synthesize) logic.</p> Property Value Module IndianaJones Piped Yes (<code>result: SearchResult</code>) Signature <code>(result, query, k, return_mode, kwargs, *, rag2f)</code> Default Empty result if no hook implements <pre><code>from rag2f.core.dto.indiana_jones_dto import SearchResult, ReturnMode\n\n@hook(\"indiana_jones_search\", priority=10)\ndef rag_search(result, query, k, return_mode, kwargs, *, rag2f):\n    \"\"\"Implement RAG search with LLM synthesis.\"\"\"\n    # 1. Retrieve relevant chunks\n    retrieve_result = rag2f.indiana_jones.execute_retrieve(query, k)\n\n    if not retrieve_result.is_ok():\n        return result\n\n    # 2. Build context from chunks\n    context = \"\\n\\n\".join([\n        f\"[{item.id}]: {item.text}\" \n        for item in retrieve_result.items\n    ])\n\n    # 3. Generate response (your LLM call)\n    response = generate_with_llm(\n        f\"Based on:\\n{context}\\n\\nAnswer: {query}\"\n    )\n\n    # 4. Return result\n    return SearchResult.success(\n        query=query,\n        response=response,\n        used_source_ids=[item.id for item in retrieve_result.items],\n        items=retrieve_result.items if return_mode == ReturnMode.WITH_ITEMS else None\n    )\n</code></pre>"},{"location":"rag2f/hooks-reference/#hook-execution-order","title":"Hook Execution Order","text":"<pre><code>sequenceDiagram\n    participant App\n    participant M as Morpheus\n    participant P100 as Hook (p=100)\n    participant P50 as Hook (p=50)\n    participant P10 as Hook (p=10)\n    participant P1 as Hook (p=1)\n\n    App-&gt;&gt;M: execute_hook(\"name\", phone)\n    M-&gt;&gt;P100: phone\n    P100--&gt;&gt;M: modified (or done=True)\n\n    alt If not done\n        M-&gt;&gt;P50: modified\n        P50--&gt;&gt;M: modified\n        M-&gt;&gt;P10: modified\n        P10--&gt;&gt;M: modified\n        M-&gt;&gt;P1: modified\n        P1--&gt;&gt;M: final\n    end\n\n    M--&gt;&gt;App: final result</code></pre>"},{"location":"rag2f/hooks-reference/#override-summary","title":"Override Summary","text":"To Override Hook Your Priority Pattern ID generation <code>get_id_input_text</code> &gt; default Return new ID Duplicate check <code>check_duplicated_input_text</code> &gt; default Return <code>True</code>/<code>False</code> Input processing <code>handle_text_foreground</code> &gt; 1 Check <code>done</code>, return <code>True</code> Retrieval <code>indiana_jones_retrieve</code> &gt; existing Return <code>RetrieveResult</code> Search/RAG <code>indiana_jones_search</code> &gt; existing Return <code>SearchResult</code> Embedder registration <code>rag2f_bootstrap_embedders</code> Any Side-effect only"},{"location":"rag2f/hooks-reference/#override-examples","title":"Override Examples","text":"Replace Default ID GeneratorBlock Duplicate ProcessingCustom Retrieval Backend <pre><code>@hook(\"get_id_input_text\", priority=100)\ndef hash_based_id(track_id, text, *, rag2f):\n    \"\"\"Use content hash instead of UUID.\"\"\"\n    import hashlib\n    return hashlib.sha256(text.encode()).hexdigest()[:16]\n</code></pre> <pre><code>@hook(\"handle_text_foreground\", priority=100)\ndef block_duplicates(done, track_id, text, *, rag2f):\n    \"\"\"Stop processing if text matches pattern.\"\"\"\n    if done:\n        return done\n    if text.startswith(\"SKIP:\"):\n        return True  # Mark as done, skip all processing\n    return False  # Let other hooks handle\n</code></pre> <pre><code>@hook(\"indiana_jones_retrieve\", priority=100)\ndef elasticsearch_retrieval(result, query, k, *, rag2f):\n    \"\"\"Use Elasticsearch instead of vector DB.\"\"\"\n    from elasticsearch import Elasticsearch\n    es = Elasticsearch()\n\n    hits = es.search(index=\"docs\", q=query, size=k)[\"hits\"][\"hits\"]\n    items = [\n        RetrievedItem(id=h[\"_id\"], text=h[\"_source\"][\"text\"], score=h[\"_score\"])\n        for h in hits\n    ]\n    return RetrieveResult.success(query=query, items=items)\n</code></pre> <p>Finding Current Priorities</p> <pre><code>for name, hooks in rag2f.morpheus.hooks.items():\n    print(f\"{name}:\")\n    for h in hooks:\n        print(f\"  {h.plugin_id}: priority={h.priority}\")\n</code></pre>"},{"location":"rag2f/hooks/","title":"Hooks","text":"<p>Hooks are rag2f's main extension point \u2014 they let plugins modify behavior without changing the core.</p>"},{"location":"rag2f/hooks/#how-hooks-work","title":"How Hooks Work","text":"<pre><code>flowchart LR\n    subgraph PIPELINE[\"Hook Pipeline\"]\n        direction LR\n        H1[\"Hook 1&lt;br/&gt;(p=10)\"] --&gt; H2[\"Hook 2&lt;br/&gt;(p=5)\"] --&gt; H3[\"Hook 3&lt;br/&gt;(p=1)\"]\n    end\n\n    IN[phone] --&gt; H1\n    H3 --&gt; OUT[modified phone]</code></pre> <p>Design Note: The pipeline pattern with <code>phone</code> enables functional composition: each hook transforms the input and passes it to the next. Priority ordering ensures that high-priority overrides can block or transform before standard plugins.</p> <p>The first positional argument (<code>phone</code>) flows through all hooks in priority order (higher first).</p>"},{"location":"rag2f/hooks/#phone-vs-done-quick-mental-model","title":"Phone vs Done (Quick Mental Model)","text":"<p>Phone is the payload that moves through a hook pipeline. Each hook can transform it and pass it on. Done is a handled flag used only for processing hooks (like <code>handle_text_foreground</code>) to avoid duplicate work.</p> Concept What it is When it matters Typical return <code>phone</code> Pipeable payload (usually a dict) Transform pipelines (<code>preprocess</code>, <code>retrieve</code>, etc.) Updated payload <code>done</code> Boolean \u201calready handled\u201d flag Processing pipelines (<code>handle_text_foreground</code>) <code>True</code>/<code>False</code> <p>Rule of thumb: if a hook is about transforming data, you\u2019re working with <code>phone</code>. If it\u2019s about claiming the work (store/embed/index once), you\u2019re working with <code>done</code>.</p>"},{"location":"rag2f/hooks/#overriding-default-behavior","title":"Overriding Default Behavior","text":"<p>The Override Pattern</p> <p>To override a default behavior, register a hook with higher priority than the default.</p> <pre><code>sequenceDiagram\n    participant App\n    participant YourHook as Your Hook (p=100)\n    participant Default as Default Hook (p=1)\n\n    App-&gt;&gt;YourHook: phone\n    YourHook--&gt;&gt;App: modified phone (stops here if handled)\n    Note right of Default: Never reached if Your Hook handles it</code></pre> <p>Design Note: The override pattern with priority exists to allow plugins to \"take control\" of a hook, preventing subsequent hooks (at lower priority) from performing redundant or conflicting processing. This is critical for testing and special cases.</p>"},{"location":"rag2f/hooks/#example-override-default-processing","title":"Example: Override Default Processing","text":"<pre><code># Default plugin (priority=1) handles text normally\n@hook(\"handle_text_foreground\", priority=1)\ndef default_handler(done, track_id, text, *, rag2f):\n    if done:\n        return done\n    # Default processing...\n    return True\n\n# YOUR plugin (priority=100) overrides it\n@hook(\"handle_text_foreground\", priority=100)\ndef my_override(done, track_id, text, *, rag2f):\n    \"\"\"Override default - runs FIRST due to higher priority.\"\"\"\n    if done:\n        return done\n\n    # Your custom processing instead\n    custom_process(track_id, text)\n    return True  # Mark as done, default never runs\n</code></pre>"},{"location":"rag2f/hooks/#the-done-pattern","title":"The <code>done</code> Pattern","text":"<p>For processing hooks like <code>handle_text_foreground</code>, use the <code>done</code> flag:</p> <pre><code>@hook(\"handle_text_foreground\", priority=50)\ndef my_handler(done, track_id, text, *, rag2f):\n    # Check if already handled by higher-priority hook\n    if done:\n        return done  # Pass through, don't re-process\n\n    # Your processing logic\n    success = process(track_id, text)\n    return success  # True = handled, False = let others try\n</code></pre>"},{"location":"rag2f/hooks/#hook-types","title":"Hook Types","text":"Pipeable (transform data)Side-effect (no piping)Processing (done pattern) <pre><code>@hook(\"preprocess\", priority=5)\ndef clean(phone, *, rag2f):\n    phone[\"text\"] = phone[\"text\"].strip()\n    return phone  # Required! Returns to next hook\n</code></pre> <pre><code>@hook(\"rag2f_bootstrap_embedders\", priority=10)\ndef setup(*, rag2f):\n    rag2f.optimus_prime.register(\"my_emb\", MyEmbedder())\n    # No return needed\n</code></pre> <pre><code>@hook(\"handle_text_foreground\", priority=10)\ndef process(done, track_id, text, *, rag2f):\n    if done:\n        return done\n    # Process...\n    return True  # Mark as handled\n</code></pre>"},{"location":"rag2f/hooks/#priority-guidelines","title":"Priority Guidelines","text":"Priority Use Case Example <code>100+</code> Override everything Testing, special cases <code>50-99</code> Custom primary impl Your main processing <code>10-49</code> Standard plugins Normal plugins <code>1-9</code> Fallback/default Core defaults <p>Higher = First</p> <p>Priority <code>100</code> runs before priority <code>1</code>.</p>"},{"location":"rag2f/hooks/#defining-hooks","title":"Defining Hooks","text":"<pre><code>from rag2f.core.morpheus.decorators import hook\n\n# Explicit name\n@hook(\"my_hook\", priority=10)\ndef handler(phone, *, rag2f):\n    return phone\n\n# Function name as hook name\n@hook(priority=5)\ndef my_hook(phone, *, rag2f):\n    return phone\n\n# Default priority (1)\n@hook\ndef my_hook(phone, *, rag2f):\n    return phone\n</code></pre>"},{"location":"rag2f/hooks/#executing-hooks","title":"Executing Hooks","text":"<pre><code># From your application\nphone = {\"text\": \"hello\"}\nphone = rag2f.morpheus.execute_hook(\"preprocess\", phone, rag2f=rag2f)\n</code></pre> <p>If no hooks registered \u2192 returns input unchanged.</p>"},{"location":"rag2f/hooks/#return-value-rules","title":"Return Value Rules","text":"Return Effect Value Passed to next hook <code>None</code> Previous value continues <code>True/False</code> For done-pattern hooks"},{"location":"rag2f/hooks/#built-in-hooks","title":"Built-in Hooks","text":"\ud83d\ude80 Bootstrap\ud83d\udce5 Johnny5 (Input)\ud83d\udd0d IndianaJones (Retrieval) Hook Signature Purpose <code>rag2f_bootstrap_embedders</code> <code>(*, rag2f)</code> Register embedders/repos at startup Hook Signature Purpose <code>get_id_input_text</code> <code>(track_id, text, *, rag2f)</code> Generate/retrieve input ID <code>check_duplicated_input_text</code> <code>(is_dup, track_id, text, *, rag2f)</code> Check duplicate input <code>handle_text_foreground</code> <code>(done, track_id, text, *, rag2f)</code> Process/store/embed input Hook Signature Purpose <code>indiana_jones_retrieve</code> <code>(result, query, k, *, rag2f)</code> Vector retrieval <code>indiana_jones_search</code> <code>(result, query, k, mode, kwargs, *, rag2f)</code> Search + LLM synthesis <p>See Hooks Reference for complete documentation with examples.</p>"},{"location":"rag2f/hooks/#custom-hooks","title":"Custom Hooks","text":"<p>Define your own hooks for custom pipelines:</p> <pre><code># Plugin A defines the hook\n@hook(\"my_custom_pipeline\", priority=10)\ndef step_one(phone, *, rag2f):\n    phone[\"step1\"] = True\n    return phone\n\n# Plugin B extends it\n@hook(\"my_custom_pipeline\", priority=5)\ndef step_two(phone, *, rag2f):\n    phone[\"step2\"] = True\n    return phone\n\n# Execute in your app\nphone = rag2f.morpheus.execute_hook(\"my_custom_pipeline\", {}, rag2f=rag2f)\n# phone = {\"step1\": True, \"step2\": True}\n</code></pre>"},{"location":"rag2f/hooks/#testing-hooks","title":"Testing Hooks","text":"<p>Hooks are plain functions \u2014 test directly:</p> <pre><code>from unittest.mock import MagicMock\n\ndef test_my_hook():\n    phone = {\"text\": \"  hello  \"}\n    result = clean(phone, rag2f=MagicMock())\n    assert result[\"text\"] == \"hello\"\n</code></pre>"},{"location":"rag2f/installation/","title":"Installation","text":""},{"location":"rag2f/installation/#requirements","title":"Requirements","text":"<ul> <li>Python 3.12+</li> </ul>"},{"location":"rag2f/installation/#install","title":"Install","text":"From Source (dev)As DependencyWith Bootstrap <pre><code>git clone &lt;your-rag2f-repo&gt;\ncd rag2f\npip install -e \".[dev]\"\n</code></pre> <pre><code>pip install rag2f\n</code></pre> <pre><code>bash scripts/bootstrap-venv.sh\nsource .venv/bin/activate\n</code></pre>"},{"location":"rag2f/installation/#project-layout","title":"Project Layout","text":"<pre><code>your_app/\n\u251c\u2500\u2500 config.json          # Spock config\n\u251c\u2500\u2500 plugins/             # Local plugins folder\n\u2502   \u2514\u2500\u2500 my_plugin/\n\u2502       \u251c\u2500\u2500 plugin.json  # Plugin metadata\n\u2502       \u2514\u2500\u2500 my_plugin.py # Hooks/tools\n\u2514\u2500\u2500 main.py\n</code></pre>"},{"location":"rag2f/installation/#quick-verify","title":"Quick Verify","text":"<pre><code>from rag2f import RAG2F\n\nasync def main():\n    rag2f = await RAG2F.create(\n        plugins_folder=\"plugins\",\n        config_path=\"config.json\"\n    )\n    print(f\"Loaded: {len(rag2f.morpheus.plugins)} plugins\")\n</code></pre>"},{"location":"rag2f/installation/#troubleshooting","title":"Troubleshooting","text":"Problem Check No plugins loaded <code>plugins_folder</code> exists, has <code>plugin.json</code> Multiple embedders Set <code>rag2f.embedder_default</code> in config Wrong plugin path Plugin's <code>get_plugin_path()</code> returns its own dir <p>See Configuration for env vars and Plugins for plugin setup.</p>"},{"location":"rag2f/plugin-anatomy/","title":"Plugin Anatomy","text":"<p>Detailed structure, lifecycle, and best practices for rag2f plugins.</p>"},{"location":"rag2f/plugin-anatomy/#plugin-structure","title":"Plugin Structure","text":"MinimalRecommended <pre><code>my_plugin/\n\u251c\u2500\u2500 plugin.toml      # Metadata (required)\n\u2514\u2500\u2500 hooks.py         # Hook implementations\n</code></pre> <pre><code>my_plugin/\n\u251c\u2500\u2500 plugin.toml          # Metadata\n\u251c\u2500\u2500 __init__.py          # Package init\n\u251c\u2500\u2500 hooks.py             # Hook implementations\n\u251c\u2500\u2500 requirements.txt     # Plugin dependencies\n\u251c\u2500\u2500 README.md            # Documentation\n\u2514\u2500\u2500 tests/\n    \u2514\u2500\u2500 test_hooks.py\n</code></pre>"},{"location":"rag2f/plugin-anatomy/#plugin-manifest","title":"Plugin Manifest","text":"plugin.toml (preferred)plugin.json <pre><code>[plugin]\nid = \"my_plugin\"\nname = \"My Plugin\"\nversion = \"1.0.0\"\ndescription = \"What this plugin does\"\n\n# Optional\nauthor_name = \"Your Name\"\nlicense = \"MIT\"\nmin_rag2f_version = \"0.1.0\"\n</code></pre> <pre><code>{\n  \"id\": \"my_plugin\",\n  \"name\": \"My Plugin\",\n  \"version\": \"1.0.0\",\n  \"module\": \"hooks.py\"\n}\n</code></pre>"},{"location":"rag2f/plugin-anatomy/#lifecycle-decorators","title":"Lifecycle Decorators","text":""},{"location":"rag2f/plugin-anatomy/#the-plugin-decorator","title":"The <code>@plugin</code> Decorator","text":"<p>Use <code>@plugin</code> for lifecycle hooks that run during plugin activation/deactivation.</p> <pre><code>from rag2f.core.morpheus.decorators import plugin\n\n@plugin\ndef activated(plugin, rag2f):\n    \"\"\"Called when plugin is loaded.\n\n    Args:\n        plugin: Plugin object with id, path, etc.\n        rag2f: RAG2F instance\n    \"\"\"\n    config = rag2f.spock.get_plugin_config(plugin.id)\n\n    # Register resources\n    rag2f.optimus_prime.register(\"my_emb\", MyEmbedder(config))\n    rag2f.xfiles.execute_register(\"my_repo\", MyRepo())\n\n@plugin\ndef deactivated(plugin, rag2f):\n    \"\"\"Called when plugin is unloaded (optional).\"\"\"\n    # Cleanup resources if needed\n    pass\n</code></pre> <p>Function Name Matters</p> <p>The function must be named <code>activated</code> or <code>deactivated</code> exactly.</p>"},{"location":"rag2f/plugin-anatomy/#plugin-vs-hook","title":"<code>@plugin</code> vs <code>@hook</code>","text":"Decorator Purpose When Called <code>@plugin</code> Lifecycle (setup/teardown) Plugin load/unload <code>@hook</code> Pipeline extension During <code>execute_hook()</code> <pre><code>sequenceDiagram\n    participant M as Morpheus\n    participant P as Plugin\n    participant H as Hooks\n\n    M-&gt;&gt;P: Load plugin\n    M-&gt;&gt;P: @plugin activated()\n    P-&gt;&gt;P: Register embedders/repos\n    M-&gt;&gt;H: Register @hook functions\n    Note right of H: Ready for execute_hook()</code></pre> <p>Design Note: The separation of <code>@plugin</code> (lifecycle) vs <code>@hook</code> (runtime) allows heavy setup (DB connections, API clients) in <code>activated()</code> that happens once, while <code>@hook</code> functions remain pure and fast, called repeatedly during execution.</p>"},{"location":"rag2f/plugin-anatomy/#the-hook-decorator","title":"The <code>@hook</code> Decorator","text":"<p>Register functions to participate in named pipelines.</p> <pre><code>from rag2f.core.morpheus.decorators import hook\n\n# Explicit name and priority\n@hook(\"preprocess\", priority=10)\ndef my_preprocess(phone, *, rag2f):\n    return phone\n\n# Use function name as hook name\n@hook(priority=5)\ndef preprocess(phone, *, rag2f):\n    return phone\n\n# Default priority (1)\n@hook\ndef preprocess(phone, *, rag2f):\n    return phone\n</code></pre>"},{"location":"rag2f/plugin-anatomy/#complete-plugin-example","title":"Complete Plugin Example","text":"hooks.py<pre><code>\"\"\"Azure OpenAI Embedder Plugin.\"\"\"\n\nfrom rag2f.core.morpheus.decorators import hook, plugin\n\n\nclass AzureEmbedder:\n    \"\"\"Azure OpenAI embedder implementation.\"\"\"\n\n    def __init__(self, endpoint: str, api_key: str, deployment: str):\n        from openai import AzureOpenAI\n        self._client = AzureOpenAI(\n            azure_endpoint=endpoint,\n            api_key=api_key,\n            api_version=\"2024-02-01\"\n        )\n        self._deployment = deployment\n\n    @property\n    def size(self) -&gt; int:\n        return 1536\n\n    def getEmbedding(self, text: str, normalize: bool = False):\n        response = self._client.embeddings.create(\n            model=self._deployment,\n            input=text\n        )\n        return response.data[0].embedding\n\n\n# ============ LIFECYCLE ============\n\n@plugin\ndef activated(plugin, rag2f):\n    \"\"\"Register embedder on plugin activation.\"\"\"\n    config = rag2f.spock.get_plugin_config(plugin.id)\n\n    # Validate required config\n    required = [\"endpoint\", \"deployment\"]\n    missing = [k for k in required if not config.get(k)]\n    if missing:\n        raise ValueError(f\"{plugin.id}: Missing config: {missing}\")\n\n    # API key from ENV\n    api_key = config.get(\"api_key\")\n    if not api_key:\n        raise ValueError(\n            f\"{plugin.id}: api_key required. \"\n            f\"Set RAG2F__PLUGINS__{plugin.id.upper()}__API_KEY\"\n        )\n\n    # Create and register embedder\n    embedder = AzureEmbedder(\n        endpoint=config[\"endpoint\"],\n        api_key=api_key,\n        deployment=config[\"deployment\"]\n    )\n\n    rag2f.optimus_prime.register(\"azure_openai\", embedder)\n\n\n# ============ HOOKS ============\n\n@hook(\"handle_text_foreground\", priority=10)\ndef embed_and_store(done, track_id, text, *, rag2f):\n    \"\"\"Store text embeddings in vector DB.\"\"\"\n    if done:\n        return done\n\n    embedder = rag2f.optimus_prime.get(\"azure_openai\")\n    repo_result = rag2f.xfiles.execute_get(\"vectors\")\n\n    if not embedder or not repo_result.is_ok():\n        return False  # Let other hooks handle\n\n    vector = embedder.getEmbedding(text)\n    repo_result.repository.insert(track_id, vector, {\"text\": text})\n\n    return True\n</code></pre> plugin.toml<pre><code>[plugin]\nid = \"azure_openai_embedder\"\nname = \"Azure OpenAI Embedder\"\nversion = \"1.0.0\"\ndescription = \"Embedder using Azure OpenAI\"\nmin_rag2f_version = \"0.1.0\"\n</code></pre> requirements.txt<pre><code>openai&gt;=1.0.0\n</code></pre>"},{"location":"rag2f/plugin-anatomy/#plugin-dependencies","title":"Plugin Dependencies","text":"requirements.txt<pre><code>openai&gt;=1.0.0\nqdrant-client&gt;=1.7.0\n</code></pre> <p>Lazy Imports</p> <p>Import heavy dependencies inside functions to speed up startup: <pre><code>@plugin\ndef activated(plugin, rag2f):\n    from openai import AzureOpenAI  # Import here, not at top\n    ...\n</code></pre></p>"},{"location":"rag2f/plugin-anatomy/#publishing-to-pypi","title":"Publishing to PyPI","text":"pyproject.toml<pre><code>[project]\nname = \"rag2f-azure-openai\"\nversion = \"1.0.0\"\ndependencies = [\"rag2f&gt;=0.1.0\", \"openai&gt;=1.0.0\"]\n\n[project.entry-points.\"rag2f.plugins\"]\nazure_openai_embedder = \"rag2f_azure_openai:get_plugin_path\"\n</code></pre> __init__.py<pre><code>from pathlib import Path\n\ndef get_plugin_path() -&gt; str:\n    return str(Path(__file__).parent)\n</code></pre>"},{"location":"rag2f/plugin-anatomy/#testing-plugins","title":"Testing Plugins","text":"tests/test_plugin.py<pre><code>import pytest\nfrom unittest.mock import MagicMock\n\ndef test_activated_validates_config():\n    \"\"\"Test that activation fails without required config.\"\"\"\n    from hooks import activated\n\n    mock_plugin = MagicMock()\n    mock_plugin.id = \"azure_openai_embedder\"\n\n    mock_rag2f = MagicMock()\n    mock_rag2f.spock.get_plugin_config.return_value = {}\n\n    with pytest.raises(ValueError, match=\"Missing config\"):\n        activated(mock_plugin, mock_rag2f)\n\ndef test_hook_handles_missing_embedder():\n    \"\"\"Test hook gracefully handles missing embedder.\"\"\"\n    from hooks import embed_and_store\n\n    mock_rag2f = MagicMock()\n    mock_rag2f.optimus_prime.get.return_value = None\n\n    result = embed_and_store(False, \"id\", \"text\", rag2f=mock_rag2f)\n    assert result == False  # Let other hooks handle\n</code></pre>"},{"location":"rag2f/plugins/","title":"Plugins &amp; hooks (Morpheus)","text":"<p>Morpheus is the plugin manager. It discovers plugins, loads them, and executes hook pipelines.</p> <p>\"You take the red pill, you stay in Wonderland.\" - Morpheus, The Matrix</p> <pre><code>  ____\n / __ \\  Morpheus\n \\_\\_\\_\\  pill\n</code></pre>"},{"location":"rag2f/plugins/#discovery-model","title":"Discovery model","text":"<pre><code>flowchart TD\n    Start[Morpheus.discover_plugins]\n    EP[Scan entry points]\n    FS[Scan filesystem ./plugins]\n    Merge[Merge plugins]\n\n    Start --&gt; EP\n    EP --&gt; FS\n    FS --&gt; Merge\n\n    Merge --&gt; Load[Load each plugin]\n    Load --&gt; Validate[Validate manifest]\n    Validate --&gt; Register[Register hooks]</code></pre> <p>Design Note: The entry points \u2192 filesystem order ensures that installed plugins (production) win over local versions (dev), avoiding ambiguity in deployments. This makes discovery deterministic and predictable.</p> <p>rag2f discovers plugins in two places (in this precedence order):</p> <ol> <li>Python entry points (installed packages)</li> <li>Filesystem plugins folder (local development)</li> </ol> <p>Entry points win over filesystem to prevent ambiguity (an installed plugin overrides a local plugin with the same id).</p>"},{"location":"rag2f/plugins/#entry-points","title":"Entry points","text":"<p>Plugins can be published as Python packages and expose an entry point in the group:</p> <ul> <li><code>rag2f.plugins</code></li> </ul> <p>The entry point must be callable and must return a string path to the plugin directory.</p> <p>Conceptual <code>pyproject.toml</code> snippet (in the plugin package):</p> <pre><code>[project.entry-points.\"rag2f.plugins\"]\nrag2f-azure-openai-embedder = \"rag2f_azure_openai_embedder:get_plugin_path\"\n</code></pre> <p>Where <code>get_plugin_path()</code> returns the on-disk folder that contains your <code>plugin.json</code> and plugin code.</p>"},{"location":"rag2f/plugins/#filesystem-plugins","title":"Filesystem plugins","text":"<p>For local development, Morpheus loads plugins from:</p> <ul> <li><code>plugins_folder</code> passed to <code>RAG2F.create(...)</code>, or</li> <li>default <code>./plugins</code></li> </ul>"},{"location":"rag2f/plugins/#plugin-metadata","title":"Plugin metadata","text":"<p>A plugin can define metadata via: - <code>plugin.json</code> (preferred) - <code>pyproject.toml</code> (can override/augment) - <code>requirements.txt</code> (optional; for plugin-scoped deps)</p> <p>rag2f merges metadata with a precedence model so you can ship packaged plugins and still support local dev.</p>"},{"location":"rag2f/plugins/#manifest-merge-and-defaults","title":"Manifest merge and defaults","text":"<ul> <li>Root-level <code>plugin.json</code> wins over nested manifests.</li> <li><code>pyproject.toml</code> can augment fields like name, description, and URLs.</li> <li>If no name is provided, rag2f derives a humanized name from the plugin id.</li> </ul>"},{"location":"rag2f/plugins/#plugin-id-and-config-namespace","title":"Plugin ID and config namespace","text":"<p>The plugin <code>id</code> is the stable identifier used for:</p> <ul> <li>config namespace: <code>plugins.&lt;plugin_id&gt;</code></li> <li>hook ownership and logging</li> <li>avoiding collisions between plugins</li> </ul> <p>Use a short, lowercase id (e.g. <code>azure_openai_embedder</code>).</p>"},{"location":"rag2f/plugins/#minimal-pluginjson","title":"Minimal <code>plugin.json</code>","text":"<pre><code>{\n  \"id\": \"hello_plugin\",\n  \"name\": \"Hello Plugin\",\n  \"version\": \"0.1.0\",\n  \"module\": \"hello_plugin.py\"\n}\n</code></pre> <p>Common optional fields:</p> <ul> <li><code>description</code>, <code>license</code>, <code>keywords</code></li> <li><code>author_name</code>, <code>author_email</code></li> <li><code>urls</code> (project/home/docs)</li> <li><code>min_rag2f_version</code>, <code>max_rag2f_version</code></li> </ul>"},{"location":"rag2f/plugins/#suggested-folder-layout","title":"Suggested folder layout","text":"<pre><code>plugins/\n  hello_plugin/\n    plugin.json\n    hello_plugin.py\n    README.md\n</code></pre> <p>If your plugin is packaged, the entry point should return the folder that contains <code>plugin.json</code>.</p>"},{"location":"rag2f/plugins/#plugin-scoped-dependencies","title":"Plugin-scoped dependencies","text":"<p>Plugins can ship their own dependencies via a local <code>requirements.txt</code>. Morpheus installs those requirements on activation so the core stays lean and plugins stay isolated.</p>"},{"location":"rag2f/plugins/#dependency-guidelines","title":"Dependency guidelines","text":"<ul> <li>Keep heavy SDKs in plugins, not core.</li> <li>Avoid importing optional dependencies at module import time.</li> <li>Validate config before initializing expensive clients.</li> </ul>"},{"location":"rag2f/plugins/#writing-hooks","title":"Writing hooks","text":"<p>A hook is a Python function decorated with <code>@hook</code>.</p> <pre><code>from rag2f.core.morpheus.decorators.hook import hook\n\n@hook(\"search\", priority=10)\ndef my_search_hook(phone, *, rag2f):\n    # phone is the \u201cpipe\u201d value that flows through hooks\n    phone[\"results\"].append(\"hello\")\n    return phone\n</code></pre>"},{"location":"rag2f/plugins/#hook-piping-model","title":"Hook piping model","text":"<p>If a hook takes at least one argument, Morpheus will pipe the first argument (<code>phone</code>) through all registered hook functions in priority order.</p> <p>If a hook takes no arguments (besides <code>rag2f</code>), it runs for side effects.</p> <p>See Hooks for details.</p>"},{"location":"rag2f/plugins/#plugin-activation-patterns","title":"Plugin activation patterns","text":"<p>Common plugin patterns:</p> <ul> <li>Register resources: add embedders or repositories during plugin initialization.</li> <li>Expose hooks: define <code>@hook</code> functions to compose behavior.</li> <li>Validate config: fail fast if required config is missing.</li> </ul> <p>Keep plugin modules focused; avoid importing heavy dependencies at import time if they are optional.</p>"},{"location":"rag2f/plugins/#lifecycle-overrides","title":"Lifecycle overrides","text":"<p>Use the <code>@plugin</code> decorator for lifecycle overrides (activation/deactivation) when you need to run setup or cleanup logic tied to the plugin itself.</p>"},{"location":"rag2f/plugins/#entry-point-troubleshooting","title":"Entry point troubleshooting","text":"<p>If an entry point returns the wrong path (e.g. <code>site-packages/</code>), the plugin will not load. Ensure your <code>get_plugin_path()</code> returns the folder containing <code>plugin.json</code>.</p>"},{"location":"rag2f/plugins/#refreshing-plugins","title":"Refreshing plugins","text":"<p>Morpheus supports cache refresh and will notify other components via callbacks when a refresh happens. This is useful in dev workflows when you are iterating on local plugins.</p>"},{"location":"rag2f/quickstart/","title":"Quickstart","text":"<p>This page shows the smallest \u201chello world\u201d you can run with rag2f.</p>"},{"location":"rag2f/quickstart/#1-install","title":"1) Install","text":"<pre><code># Recommended: Dev Container (VS Code / devcontainers CLI)\n# - Open the repo in the dev container and wait for the container to build\npip install -e .\n</code></pre> <p>(If you prefer a local venv instead of a dev container: <code>python -m venv .venv &amp;&amp; source .venv/bin/activate</code>.)</p>"},{"location":"rag2f/quickstart/#2-create-a-config-optional","title":"2) Create a config (optional)","text":"<p>rag2f can run with an empty config, but most real usage needs at least an embedder and one repository.</p> <p>Create <code>config.json</code>:</p> <pre><code>{\n  \"rag2f\": {\n    \"embedder_default\": \"my_embedder\"\n  },\n  \"plugins\": {\n    \"my_embedder_plugin\": {\n      \"api_key\": \"...\"\n    }\n  }\n}\n</code></pre>"},{"location":"rag2f/quickstart/#3-add-a-tiny-local-plugin-optional","title":"3) Add a tiny local plugin (optional)","text":"<p>Local plugins are the fastest way to test hooks and registries.</p> <p>Create a plugin folder:</p> <pre><code>plugins/\n  hello_plugin/\n    plugin.json\n    hello_plugin.py\n</code></pre> <p>Example <code>plugin.json</code>:</p> <pre><code>{\n  \"id\": \"hello_plugin\",\n  \"name\": \"Hello Plugin\",\n  \"version\": \"0.1.0\",\n  \"module\": \"hello_plugin.py\"\n}\n</code></pre> <p>Example <code>hello_plugin.py</code>:</p> <pre><code>from rag2f.core.morpheus.decorators.hook import hook\n\n@hook(\"preprocess\", priority=5)\ndef add_tag(phone, *, rag2f):\n    phone[\"tags\"] = phone.get(\"tags\", []) + [\"hello\"]\n    return phone\n</code></pre>"},{"location":"rag2f/quickstart/#4-start-an-instance-and-discover-plugins","title":"4) Start an instance and discover plugins","text":"<pre><code>flowchart TD\n    App[Your app]\n    Create[RAG2F.create]\n    Plugin[Discover plugins]\n    Reg[Registries ready]\n    Hook[Execute hooks]\n\n    App --&gt; Create\n    Create --&gt; Plugin\n    Plugin --&gt; Reg\n    Reg --&gt; Hook\n    Hook --&gt; App</code></pre> <p>Design Note: The create \u2192 discover \u2192 register \u2192 execute cycle keeps clean separation between setup (async) and runtime (sync), allowing early validation and fail-fast if configuration or plugins have issues.</p> <pre><code>import asyncio\nfrom rag2f.core.rag2f import RAG2F\n\nasync def main():\n    rag2f = await RAG2F.create(\n        plugins_folder=\"plugins/\",    # optional; defaults to ./plugins\n        config_path=\"config.json\",    # optional\n    )\n\n    # Embedder\n    embedder = rag2f.optimus_prime.get_default()\n    v = embedder.getEmbedding(\"hello rag2f\")\n\n    print(len(v), v[:5])\n\nasyncio.run(main())\n</code></pre>"},{"location":"rag2f/quickstart/#5-compose-a-minimal-pipeline","title":"5) Compose a minimal pipeline","text":"<p>rag2f does not impose a pipeline; you compose one with hooks and registries:</p> <pre><code>phone = {\"text\": \"hello rag2f\"}\nphone = rag2f.morpheus.execute_hook(\"preprocess\", phone, rag2f=rag2f)\nphone = rag2f.morpheus.execute_hook(\"retrieve\", phone, rag2f=rag2f)\nphone = rag2f.morpheus.execute_hook(\"rerank\", phone, rag2f=rag2f)\nphone = rag2f.morpheus.execute_hook(\"generate\", phone, rag2f=rag2f)\n</code></pre> <p>Hooks are optional. If no plugin implements a hook, the phone passes through unchanged.</p>"},{"location":"rag2f/quickstart/#6-use-repositories-xfiles","title":"6) Use repositories (XFiles)","text":"<p>Once a repository plugin is registered, you can fetch it by name/id and call protocol methods based on capabilities.</p> <p>Conceptually:</p> <pre><code>repo_result = rag2f.xfiles.execute_get(\"primary\")\nif not repo_result.is_ok() or not repo_result.repository:\n    raise LookupError(\"Repository 'primary' not found\")\nrepo = repo_result.repository\n\n# Minimal CRUD\nawait repo.insert({\"id\": \"1\", \"text\": \"hello\"})\n\n# Optional query / vector search if supported by the repository\nrows = await repo.find({\"where\": {\"field\": \"text\", \"op\": \"contains\", \"value\": \"hello\"}})\n</code></pre> <p>See Repositories (XFiles) for the real contracts and <code>QuerySpec</code> shapes.</p>"},{"location":"rag2f/quickstart/#example-walkthrough-tiny-in-memory-notes-rag","title":"Example walkthrough: tiny in-memory \"notes RAG\"","text":"<p>This walkthrough is fully local (no external APIs) and touches the main pieces: plugins, embedders, repositories, and a hook-based retrieval step. You can run it end-to-end to verify the repo works on your machine.</p>"},{"location":"rag2f/quickstart/#1-create-a-local-demo-plugin","title":"1) Create a local demo plugin","text":"<pre><code>plugins/\n  tiny_demo/\n    plugin.json\n    tiny_demo.py\n</code></pre> <p><code>plugins/tiny_demo/plugin.json</code>:</p> <pre><code>{\n  \"id\": \"tiny_demo\",\n  \"name\": \"Tiny Demo Plugin\",\n  \"version\": \"0.1.0\",\n  \"module\": \"tiny_demo.py\"\n}\n</code></pre> <p><code>plugins/tiny_demo/tiny_demo.py</code>:</p> <pre><code>from rag2f.core.morpheus.decorators import hook, plugin\nfrom rag2f.core.xfiles import BaseRepository, minimal_crud_capabilities\n\n\nclass InMemoryRepo(BaseRepository):\n    def __init__(self, name=\"tiny_repo\"):\n        self._name = name\n        self._rows = {}\n\n    @property\n    def name(self) -&gt; str:\n        return self._name\n\n    def capabilities(self):\n        return minimal_crud_capabilities()\n\n    def get(self, id, select=None):\n        return self._rows[id]\n\n    def insert(self, id, item):\n        self._rows[id] = item\n\n    def update(self, id, patch):\n        self._rows[id] = {**self._rows[id], **patch}\n\n    def delete(self, id):\n        self._rows.pop(id, None)\n\n    def all(self):\n        return list(self._rows.values())\n\n    def _get_native_handle(self, kind: str):\n        raise NotImplementedError(\"Native handles not supported in this demo\")\n\n\nclass TinyEmbedder:\n    \"\"\"Toy embedder for the demo: keyword presence vector.\"\"\"\n\n    _keys = (\"password\", \"refund\", \"hours\")\n\n    @property\n    def size(self) -&gt; int:\n        return len(self._keys)\n\n    def getEmbedding(self, text: str, *, normalize: bool = False):\n        text = text.lower()\n        vec = [1.0 if key in text else 0.0 for key in self._keys]\n        if normalize:\n            norm = (sum(v * v for v in vec) ** 0.5) or 1.0\n            vec = [v / norm for v in vec]\n        return vec\n\n\n@plugin\ndef activated(plugin, rag2f):\n    \"\"\"Lifecycle hook: register the demo embedder + repo.\"\"\"\n    if not rag2f.optimus_prime.has(\"tiny_embedder\"):\n        rag2f.optimus_prime.register(\"tiny_embedder\", TinyEmbedder())\n\n    if not rag2f.xfiles.has(\"tiny_repo\"):\n        result = rag2f.xfiles.execute_register(\n            \"tiny_repo\",\n            InMemoryRepo(),\n            meta={\"type\": \"memory\", \"domain\": \"demo\"},\n        )\n        if result.is_error():\n            raise RuntimeError(result.detail.message)\n\n\n@hook(\"retrieve\", priority=10)\ndef retrieve(phone, *, rag2f):\n    \"\"\"Naive retrieval: cosine over keyword vectors.\"\"\"\n    repo_result = rag2f.xfiles.execute_get(\"tiny_repo\")\n    repo = repo_result.repository if repo_result.is_ok() else None\n    embedder = rag2f.optimus_prime.get(\"tiny_embedder\")\n    if repo is None or embedder is None:\n        return phone\n\n    query_vec = embedder.getEmbedding(phone[\"query\"], normalize=True)\n    results = []\n    for row in repo.all():\n        score = sum(a * b for a, b in zip(query_vec, row[\"embedding\"], strict=False))\n        results.append({\"id\": row[\"id\"], \"text\": row[\"text\"], \"score\": score})\n\n    results.sort(key=lambda r: r[\"score\"], reverse=True)\n    phone[\"results\"] = results[: phone.get(\"top_k\", 3)]\n    return phone\n</code></pre> <p>Note: the lifecycle function must be named <code>activated</code> to run on plugin load.</p>"},{"location":"rag2f/quickstart/#2-create-a-runnable-script","title":"2) Create a runnable script","text":"<p><code>examples/tiny_demo.py</code>:</p> <pre><code>import asyncio\nfrom rag2f.core.rag2f import RAG2F\n\n\nasync def main():\n    rag2f = await RAG2F.create(plugins_folder=\"plugins/\")\n\n    repo_result = rag2f.xfiles.execute_get(\"tiny_repo\")\n    repo = repo_result.repository if repo_result.is_ok() else None\n    embedder = rag2f.optimus_prime.get(\"tiny_embedder\")\n    if repo is None or embedder is None:\n        raise RuntimeError(\"Demo plugin did not load\")\n\n    docs = {\n        \"pwd_reset\": \"Reset your password in the account settings.\",\n        \"refund_policy\": \"Refunds are available within 30 days.\",\n        \"support_hours\": \"Support hours are Mon-Fri 9-5.\",\n    }\n\n    for doc_id, text in docs.items():\n        repo.insert(\n            doc_id,\n            {\n                \"id\": doc_id,\n                \"text\": text,\n                \"embedding\": embedder.getEmbedding(text, normalize=True),\n            },\n        )\n\n    phone = {\"query\": \"I forgot my password\", \"top_k\": 2}\n    phone = rag2f.morpheus.execute_hook(\"retrieve\", phone, rag2f=rag2f)\n\n    for hit in phone[\"results\"]:\n        print(f\"{hit['id']} (score={hit['score']:.2f}): {hit['text']}\")\n\n\nasyncio.run(main())\n</code></pre>"},{"location":"rag2f/quickstart/#3-run-it","title":"3) Run it","text":"<pre><code>python examples/tiny_demo.py\n</code></pre> <p>Expected: <code>pwd_reset</code> should be the top hit (score ~1.00).</p>"},{"location":"rag2f/quickstart/#7-add-a-simple-repository-plugin-sketch","title":"7) Add a simple repository plugin (sketch)","text":"<p>Repository plugins register themselves in activation or via hooks:</p> <pre><code>from rag2f.core.xfiles import BaseRepository\n\nclass MemoryRepo(BaseRepository):\n    capabilities = {\"queryable\": False, \"vector_search\": False, \"graph_traversal\": False}\n    def __init__(self):\n        self._rows = {}\n    def insert(self, data):\n        self._rows[data[\"id\"]] = data\n    def get(self, id):\n        return self._rows.get(id)\n    def update(self, id, data):\n        self._rows[id] = {**self._rows.get(id, {}), **data}\n    def delete(self, id):\n        self._rows.pop(id, None)\n\ndef activate(rag2f):\n    result = rag2f.xfiles.execute_register(\n        \"memory\",\n        MemoryRepo(),\n        meta={\"type\": \"memory\", \"domain\": \"demo\"},\n    )\n    if result.is_error():\n        raise ValueError(result.detail.message)\n</code></pre>"},{"location":"rag2f/quickstart/#8-add-a-track-id-for-idempotency","title":"8) Add a track ID for idempotency","text":"<p>If your input pipeline needs idempotency or tracing, include a track ID in your phone payload and let downstream hooks keep it attached to results:</p> <pre><code>import uuid\nphone = {\"id\": uuid.uuid4().hex, \"text\": \"hello rag2f\"}\n</code></pre>"},{"location":"rag2f/quickstart/#next-steps","title":"Next steps","text":"<ul> <li>Configure rag2f with Spock</li> <li>Build a plugin and register it via entry points</li> <li>Implement a repository plugin using XFiles protocols</li> </ul>"},{"location":"rag2f/repositories/","title":"Repositories (XFiles)","text":"<p>XFiles is rag2f\u2019s registry for heterogeneous repositories: SQL, vector databases, document stores, graphs, or hybrids.</p> <p>rag2f intentionally does not flatten every backend into a lowest-common-denominator API. Instead, it defines minimal contracts and lets repositories opt into richer protocols.</p> <p>\"The truth is out there.\" - The X-Files</p>"},{"location":"rag2f/repositories/#registration-flow","title":"Registration Flow","text":"<pre><code>sequenceDiagram\n    participant Plugin\n    participant Morpheus\n    participant XF as XFiles\n\n    Plugin-&gt;&gt;Morpheus: @hook rag2f_bootstrap_embedders\n    Morpheus-&gt;&gt;Plugin: execute hook\n    Plugin-&gt;&gt;XF: execute_register(\"users_db\", repo, meta)\n    XF-&gt;&gt;XF: validate + cache\n    XF--&gt;&gt;Plugin: RegisterResult</code></pre>"},{"location":"rag2f/repositories/#repository-protocols","title":"Repository protocols","text":"<p>A repository plugin implements one or more of these contracts:</p> <ul> <li>BaseRepository: minimal CRUD + capabilities + native escape hatch</li> <li>QueryableRepository: <code>find()</code> with <code>QuerySpec</code></li> <li>VectorSearchRepository: <code>vector_search()</code> for embedding retrieval</li> <li>GraphTraversalRepository: <code>traverse()</code> for graph queries</li> </ul> <p>Use capabilities to determine what you can safely call.</p>"},{"location":"rag2f/repositories/#capabilities","title":"Capabilities","text":"<pre><code>flowchart TD\n    Repo[Repository]\n    Caps{Check capabilities}\n    Vec[vector_search]\n    Query[find with QuerySpec]\n    Graph[traverse]\n\n    Repo --&gt; Caps\n    Caps --&gt;|vector_search=true| Vec\n    Caps --&gt;|queryable=true| Query\n    Caps --&gt;|graph_traversal=true| Graph</code></pre> <p>Design Note: Capabilities avoid the \"lowest common denominator\" problem: instead of forcing all repositories to implement methods they don't support (e.g. vector search on pure SQL), each repo explicitly declares what it can do. This makes plugins more honest and prevents runtime errors.</p> <p>Repositories declare capabilities (e.g. supports vector search, supports graph traversal). XFiles validates that the repository methods match the declared capabilities.</p> <p>This makes it harder to: - accidentally call vector search on a SQL-only repo, - ship a plugin that claims features it doesn\u2019t implement.</p>"},{"location":"rag2f/repositories/#capability-driven-calling","title":"Capability-driven calling","text":"<p>Before calling advanced methods, check capabilities or guard in your app:</p> <pre><code>result = xfiles.execute_get(\"users_db\")\nif result.is_ok() and result.repository:\n    repo = result.repository\n    if repo.capabilities.get(\"vector_search\"):\n        repo.vector_search(...)\n</code></pre> <p>Example capability declaration (conceptual):</p> <pre><code>capabilities = {\n    \"queryable\": True,\n    \"vector_search\": False,\n    \"graph_traversal\": False,\n}\n</code></pre>"},{"location":"rag2f/repositories/#queryspec","title":"QuerySpec","text":"<p>Queryable repositories accept a <code>QuerySpec</code> structure to express filters, pagination and projection. The exact shape lives in <code>rag2f.core.xfiles.types</code>, but conceptually:</p> <pre><code>from rag2f.core.xfiles import QuerySpec, eq, and_\n\nquery = QuerySpec(\n    select=[\"id\", \"email\"],\n    where=and_(eq(\"status\", \"active\"), eq(\"tier\", \"pro\")),\n    order_by=[\"-created_at\"],\n    limit=10,\n)\nrows = repo.find(query)\n</code></pre>"},{"location":"rag2f/repositories/#minimal-repository-shape","title":"Minimal repository shape","text":"<p>At minimum, a repository should provide:</p> <ul> <li><code>insert(data)</code> to add items</li> <li><code>get(id)</code> to retrieve by identifier</li> <li><code>update(id, data)</code> to modify</li> <li><code>delete(id)</code> to remove</li> <li><code>capabilities()</code> or <code>capabilities</code> metadata</li> </ul> <p>If you implement richer protocols, document the expected payloads in your plugin README.</p>"},{"location":"rag2f/repositories/#native-access","title":"Native access","text":"<p>For advanced use, repositories can expose native handles:</p> <pre><code>client = repo.native(\"primary\")\n# now you're in backend-specific territory\n</code></pre> <p>This \u201cescape hatch\u201d is deliberate: - rag2f keeps contracts minimal, - you can still use vendor-specific power when you want it.</p>"},{"location":"rag2f/repositories/#registering-repositories","title":"Registering repositories","text":"<p>Repository registration is typically performed by plugins via XFiles hooks or explicit registration calls (depending on your plugin design). Registration uses the Result pattern, so check the returned <code>RegisterResult</code> instead of catching exceptions.</p> <p>See Architecture for how XFiles sits in the overall system.</p>"},{"location":"rag2f/repositories/#api-reference","title":"API Reference","text":"Method Description <code>execute_register(id, repo, meta=None)</code> Register repository instance <code>execute_get(id)</code> Fetch repository by ID <code>execute_search_by_meta(**criteria)</code> Search repositories by metadata <code>execute_search_by_capability(predicate)</code> Search repositories by capability predicate <code>has(id)</code> Check existence <code>list_ids()</code> List all registered IDs <code>unregister(id)</code> Remove repository <code>get_typed(id, protocol)</code> Return repo only if it matches protocol <code>get_meta(id)</code> Get stored metadata <code>get_capabilities(id)</code> Get declared capabilities"},{"location":"rag2f/repositories/#registration-policy","title":"Registration policy","text":"<ul> <li>Same instance + same ID \u2192 OK (idempotent)</li> <li>Different instance + existing ID \u2192 error (use a new ID or unregister first)</li> </ul>"},{"location":"rag2f/repositories/#repository-metadata","title":"Repository metadata","text":"<p>Use metadata to help your app select the right backend:</p> <pre><code>users_result = xfiles.execute_register(\n    \"users_db\",\n    users_repo,\n    meta={\"type\": \"postgresql\", \"domain\": \"users\"},\n)\nif users_result.is_error():\n    raise ValueError(users_result.detail.message)\n\npapers_result = xfiles.execute_register(\n    \"papers\",\n    papers_repo,\n    meta={\"type\": \"vector\", \"domain\": \"research\"},\n)\nif papers_result.is_error():\n    raise ValueError(papers_result.detail.message)\n</code></pre> <p>Metadata is not enforced by the core, but it provides a stable filter surface for your application.</p>"},{"location":"rag2f/result-pattern/","title":"Result Pattern","text":"<p>rag2f uses a typed Result pattern for expected outcomes. Exceptions are reserved for system errors only.</p>"},{"location":"rag2f/result-pattern/#expected-vs-exceptions","title":"Expected vs Exceptions","text":"<pre><code>flowchart TD\n    Op[Operation]\n    Op --&gt; Expected{Expected&lt;br/&gt;outcome?}\n    Expected --&gt;|Yes| Result[Return Result]\n    Expected --&gt;|No| Exception[Raise Exception]\n\n    Result --&gt; OK[is_ok: use data]\n    Result --&gt; Err[is_error: check detail]\n\n    Exception --&gt; Catch[try/except]</code></pre> Expected States System Errors Empty input Backend crash Duplicate Timeout Not found Connection failure No results Invariant violation"},{"location":"rag2f/result-pattern/#status-codes","title":"Status Codes","text":"CommonJohnny5IndianaJonesXFiles Code Meaning <code>EMPTY</code> Input/query empty <code>INVALID</code> Invalid format <code>NOT_FOUND</code> Resource missing Code Meaning <code>DUPLICATE</code> Already processed <code>NOT_HANDLED</code> No hook handled Code Meaning <code>NO_RESULTS</code> Query returned nothing <code>DEGRADED</code> Partial failure Code Meaning <code>ALREADY_EXISTS</code> Key collision <code>CACHE_MISS</code> Not in cache"},{"location":"rag2f/result-pattern/#usage","title":"Usage","text":"<pre><code># Johnny5\nresult = rag2f.johnny5.execute_handle_text_foreground(text)\nif result.is_ok():\n    print(f\"Stored: {result.track_id}\")\nelse:\n    print(f\"Rejected: {result.detail.code}\")  # empty, duplicate, not_handled\n\n# IndianaJones  \nresult = rag2f.indiana_jones.execute_search(query)\nif result.is_ok():\n    print(result.response)\n\n# XFiles\nresult = rag2f.xfiles.execute_get(\"vectors\")\nif result.is_ok() and result.repository:\n    repo = result.repository\n</code></pre>"},{"location":"rag2f/troubleshooting/","title":"Troubleshooting","text":"<pre><code>flowchart TD\n    Problem[Problem]\n    Problem --&gt; Plugin{Plugin&lt;br/&gt;issues?}\n    Problem --&gt; Hook{Hook&lt;br/&gt;issues?}\n    Problem --&gt; Config{Config&lt;br/&gt;issues?}\n\n    Plugin --&gt; P1[Check plugins_folder]\n    Plugin --&gt; P2[Verify plugin.json]\n\n    Hook --&gt; H1[Check @hook decorator]\n    Hook --&gt; H2[Verify hook name]\n\n    Config --&gt; C1[Check config_path]\n    Config --&gt; C2[Verify env prefix]\n\n    P1 --&gt; P1a[Folder exists]\n    P1 --&gt; P1b[Readable permissions]\n    H1 --&gt; H1a[Decorator import path correct]</code></pre>"},{"location":"rag2f/troubleshooting/#debug-checklist","title":"Debug Checklist","text":"Category Check Fix Plugins <code>plugins_folder</code> exists Pass correct path to <code>RAG2F.create()</code> <code>plugin.json</code> present Create with valid <code>id</code> and <code>module</code> Entry point returns right path Fix <code>get_plugin_path()</code> in plugin Hooks Function has <code>@hook</code> Add decorator Hook name exact match Check spelling and case Plugin activated Check startup logs Config File path correct Verify <code>config_path</code> Env prefix correct Use <code>RAG2F__RAG2F__</code> or <code>RAG2F__PLUGINS__</code> Plugin namespace Use <code>plugins.&lt;plugin_id&gt;.*</code> Embedders Default configured Set <code>rag2f.embedder_default</code> Multiple registered Remove extras or set default Repos Capability declared Implement required methods Registry lookup Check key casing, call <code>list_keys()</code>"},{"location":"rag2f/troubleshooting/#common-errors","title":"Common Errors","text":"Plugin IssuesHook IssuesConfig Issues Error Cause Solution Plugin not discovered Missing folder or <code>plugin.json</code> Verify path and metadata Entry point returns site-packages Broken <code>get_plugin_path()</code> Return plugin's own directory Duplicate hooks Same plugin loaded twice Uninstall duplicate or change id Error Cause Solution Hook not running Missing <code>@hook</code> decorator Add decorator Wrong hook called Name mismatch Check exact hook name Runtime error in hook Unhandled exception Add try/except, check logs Error Cause Solution Value not found Wrong path Check <code>plugins.&lt;id&gt;</code> matches plugin id Env not applying Wrong prefix Use <code>RAG2F__SECTION__KEY</code> format No default embedder Missing config Set <code>rag2f.embedder_default</code>"},{"location":"rag2f/troubleshooting/#quick-diagnostics","title":"Quick Diagnostics","text":"<pre><code># Check plugin count\nprint(f\"Plugins: {len(rag2f.morpheus.plugins)}\")\n\n# List registered embedders\nprint(f\"Embedders: {rag2f.optimus_prime.list_keys()}\")\n\n# Check config loaded\nprint(f\"Config loaded: {rag2f.spock.is_loaded}\")\n\n# List repositories\nprint(f\"Repos: {rag2f.xfiles.list_keys()}\")\n</code></pre>"}]}