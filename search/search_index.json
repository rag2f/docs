{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Home","text":""},{"location":"#rag2f-documentation-hub","title":"RAG2F Documentation Hub","text":"<p>This repository hosts docs for the rag2f ecosystem.</p> <p>The core idea: rag2f is a plugin-first kernel built around registries + hooks, with optional dependency scope kept in plugins.</p>"},{"location":"#how-the-docs-are-organized","title":"How the docs are organized","text":"<ul> <li>RAG2F covers the core kernel, registries, hooks, and plugin contracts.</li> </ul>"},{"location":"#plugin-list","title":"Plugin list","text":"<ul> <li>rag2f_azure_openai_embedder: Azure OpenAI embedder plugin that uses Spock config.</li> <li>rag2f_macgyver: in-memory plugin for fast local experiments.</li> </ul>"},{"location":"#projects","title":"Projects","text":"<ul> <li>rag2f: the plugin-first kernel for composing RAG systems   \u2192 see the rag2f docs</li> </ul>"},{"location":"#contributing","title":"Contributing","text":"<p>Docs are written in Markdown under <code>mkdocs/</code> and published with MkDocs Material.</p> <ul> <li>Edit or add pages under <code>mkdocs/</code></li> <li>Update <code>mkdocs.yml</code> navigation if you add new pages</li> </ul>"},{"location":"contributing/","title":"Contributing","text":"<p>This page focuses on contributing to the rag2f codebase (core + plugins) in the <code>rag2f-main</code> repo. Docs live in this repo under <code>mkdocs/</code>.</p>"},{"location":"contributing/#repo-layout-at-a-glance","title":"Repo layout at a glance","text":"<ul> <li><code>src/</code>: src-layout package (importable code lives here)</li> <li><code>tests/</code>: pytest suite</li> <li><code>scripts/</code>: release helper scripts</li> <li><code>pyproject.toml</code>: build, Ruff, and pytest config</li> </ul>"},{"location":"contributing/#local-development-workflow","title":"Local development workflow","text":"<p>Minimal setup (venv or Dev Container):</p> <pre><code>python -m venv .venv\nsource .venv/bin/activate\npip install -e '.[dev]'\n</code></pre> <p>Run tests:</p> <pre><code>pytest\n</code></pre> <p>Enable pre-commit hooks (optional, but recommended):</p> <pre><code>pre-commit install\npre-commit run --all-files\n</code></pre>"},{"location":"contributing/#techy-python-rules-ruff","title":"Techy: Python rules (Ruff)","text":"<p>rag2f uses Ruff for linting, import sorting, and formatting. Key settings in <code>rag2f-main/pyproject.toml</code>:</p> <ul> <li>Target version: <code>py312</code></li> <li>Line length: <code>99</code></li> <li>Lint rules: <code>E</code>, <code>F</code>, <code>I</code>, <code>UP</code>, <code>B</code>, <code>SIM</code>, <code>S</code></li> <li><code>E501</code> (line length) is ignored; formatter handles wrapping</li> </ul> <p>Local commands:</p> <pre><code>ruff check src tests\nruff check --fix src tests\nruff format src tests\nruff format --check src tests\n</code></pre>"},{"location":"contributing/#packaging-guardrails","title":"Packaging guardrails","text":"<p>The repo enforces a src-layout build and versioning via <code>setuptools-scm</code>. Expect checks for:</p> <ul> <li><code>dynamic = [\"version\"]</code> in <code>pyproject.toml</code></li> <li><code>setuptools-scm</code> in <code>build-system.requires</code></li> <li><code>local_scheme = \"no-local-version\"</code></li> <li><code>src/rag2f/_version.py</code> generation</li> <li><code>__init__.py</code> in all Python package directories</li> </ul> <p>These are validated in CI and by local scripts.</p>"},{"location":"contributing/#cicd-overview-from-the-current-workflows","title":"CI/CD overview (from the current workflows)","text":"<p>The rag2f repo uses GitHub Actions workflows stored in <code>.github/workflows/</code>:</p>"},{"location":"contributing/#ruffyml","title":"<code>ruff.yml</code>","text":"<ul> <li>Trigger: pushes to <code>main</code>, pull requests</li> <li>Jobs: lint + format check (<code>ruff check</code>, <code>ruff format --check</code>)</li> </ul>"},{"location":"contributing/#ci-dev-testpypiyml","title":"<code>ci-dev-testpypi.yml</code>","text":"<ul> <li>Trigger: pushes and PRs to <code>main</code></li> <li>Jobs:</li> <li>Ruff lint/format</li> <li><code>pip-audit</code> for dependency vulnerabilities</li> <li>pytest (full test run)</li> <li>repo validation (src layout, <code>__init__.py</code>, <code>pyproject.toml</code> checks)</li> <li>build and publish to TestPyPI on <code>main</code> pushes</li> <li>smoke test that installs the TestPyPI artifact and verifies <code>__version__</code></li> </ul> <p>Build versioning uses <code>NEXT_VERSION</code> + <code>SETUPTOOLS_SCM_PRETEND_VERSION_FOR_RAG2F</code>.</p>"},{"location":"contributing/#release-tagsyml","title":"<code>release-tags.yml</code>","text":"<ul> <li>Trigger: tags matching <code>v*</code></li> <li>Checks tag commit is on <code>main</code></li> <li>Builds wheel + sdist, creates checksums</li> <li>Publishes to PyPI</li> <li>Creates a GitHub Release and runs a PyPI install smoke test</li> </ul>"},{"location":"contributing/#local-release-helpers","title":"Local release helpers","text":"<p>The <code>scripts/</code> folder mirrors parts of CI for local checks:</p> <ul> <li><code>scripts/test_release_setup.sh</code>: quick validation of versioning + build artifacts</li> <li><code>scripts/build-local.sh</code>: full local build and install test</li> </ul> <p>These are useful before pushing or tagging a release.</p>"},{"location":"deep_thought/","title":"Deep Thought","text":"<p>Deep Thought is a collection of design notes and experiments around the rag2f kernel. It is intentionally informal and focuses on:</p> <ul> <li>trade-offs and architecture rationale</li> <li>plugin boundaries and contracts</li> <li>future-facing ideas that may or may not land in core</li> </ul> <p>If you are building plugins or debating architecture choices, these notes are a good starting point.</p>"},{"location":"deep_thought/design-notes/","title":"Design notes","text":"<p>This page captures the reasoning behind rag2f design choices.</p>"},{"location":"deep_thought/design-notes/#kernel-boundaries","title":"Kernel boundaries","text":"<p>The core stays deliberately small. When something is volatile or vendor-specific, it belongs in a plugin. This protects the kernel from rapid infrastructure churn.</p>"},{"location":"deep_thought/design-notes/#contracts-over-inheritance","title":"Contracts over inheritance","text":"<p>Protocols and capability checks favor structural typing over deep class hierarchies. This keeps integrations lightweight and reduces the cost of supporting new backends.</p>"},{"location":"deep_thought/design-notes/#pipelines-live-outside-core","title":"Pipelines live outside core","text":"<p>rag2f avoids baking in a single \"retrieve \u2192 rerank \u2192 generate\" flow. Instead, hooks and registries enable multiple pipeline shapes without a monolithic orchestrator.</p>"},{"location":"deep_thought/design-notes/#why-registry-names-are-narrative","title":"Why registry names are narrative","text":"<p>The named components (Spock, Morpheus, OptimusPrime, XFiles, Johnny5) emphasize:</p> <ul> <li>small surface area</li> <li>clear responsibilities</li> <li>minimal coupling</li> </ul> <p>The intent is to prevent a \"god object\" core and to keep extension points explicit.</p>"},{"location":"deep_thought/design-notes/#open-questions","title":"Open questions","text":"<p>Topics still being explored:</p> <ul> <li>How to express multi-tenant configuration without leaking tenant state into the kernel.</li> <li>Where to draw the line between hooks and higher-level workflow engines.</li> <li>Best practices for plugin dependency isolation at scale.</li> </ul>"},{"location":"rag2f/","title":"rag2f overview","text":"<p>rag2f (short for \"rag to the future\") is a plugin-first, entry-point\u2013driven kernel for composing Retrieval-Augmented Generation (RAG) systems without forcing a single pipeline shape.</p> <p>It gives you a small, stable core (the \u201ckernel\u201d) and pushes volatile integrations (vector DBs, embedders, stores, orchestration) into plugins so you can swap infrastructure without rewriting your whole app.</p> <p>rag2f is not a turnkey RAG pipeline. Pipelines live in plugins or in your application.</p>"},{"location":"rag2f/#the-problem-it-solves","title":"The problem it solves","text":"<p>RAG stacks depend on fast-moving infrastructure (vector DBs, LLM SDKs, hosted services). That creates two recurring problems:</p> <ul> <li>Supply-chain risk: dependency churn breaks builds, increases attack surface, and forces migrations.</li> <li>Architecture rigidity: \u201cone pipeline to rule them all\u201d hides backend-specific power and makes swaps painful.</li> </ul> <p>rag2f addresses both by: - keeping the base install lean, - pushing integrations into plugins with scoped dependencies, - using explicit contracts (protocols) and capability declarations.</p>"},{"location":"rag2f/#why-rag2f","title":"Why rag2f","text":"<p>The kernel stays intentionally small so you can evolve your stack safely. In practice, this means:</p> <ul> <li>plugins own their dependencies instead of ballooning the core,</li> <li>registries give you a stable surface area for embedders and repositories,</li> <li>hooks let plugins compose behavior without a forced pipeline shape.</li> </ul>"},{"location":"rag2f/#design-goals","title":"Design goals","text":"<ul> <li>Small, stable core: registries + hooks only, no opinionated pipeline.</li> <li>Volatile edges: backends and SDKs live in plugins, not the kernel.</li> <li>Explicit contracts: protocols and capabilities make features clear.</li> <li>Instance isolation: each RAG2F instance has its own config and registries.</li> <li>Deterministic discovery: entry-point plugins override filesystem plugins.</li> </ul>"},{"location":"rag2f/#when-rag2f-is-a-good-fit","title":"When rag2f is a good fit","text":"<p>Use rag2f when you need: - multiple storage backends or embedding providers, - a pluggable architecture with strict boundaries, - a core you can keep stable while integrations evolve.</p> <p>rag2f may not be a fit when you want a single, fixed pipeline with all decisions pre-made.</p>"},{"location":"rag2f/#what-you-get-in-core","title":"What you get in core","text":"<p>A <code>RAG2F</code> instance wires together a few intentionally-named components:</p> <ul> <li>Spock: configuration manager (JSON + env; env overrides JSON)</li> <li>Morpheus: plugin &amp; hook manager (entry points + filesystem)</li> <li>OptimusPrime: embedder registry (embedders contributed by plugins)</li> <li>XFiles: repository registry (SQL/vector/graph/document repositories)</li> <li>Johnny5: input manager (small deterministic pre-processing)</li> </ul>"},{"location":"rag2f/#registries-hooks-mental-model","title":"Registries + hooks (mental model)","text":"<p>rag2f is easiest to reason about as registries + hooks:</p> <ul> <li>Registries store validated implementations (embedders, repositories).</li> <li>Hooks let plugins contribute those implementations (and compose behavior).</li> <li>The core stays stable while plugins evolve independently.</li> </ul>"},{"location":"rag2f/#plugin-discovery-model","title":"Plugin discovery model","text":"<p>Plugins are discovered in two places (in precedence order):</p> <ol> <li>Entry points (<code>rag2f.plugins</code>) for installed packages</li> <li>Filesystem plugins (local development in <code>./plugins</code>)</li> </ol> <p>Entry points win over filesystem to avoid ambiguity in production.</p>"},{"location":"rag2f/#the-typical-lifecycle","title":"The typical lifecycle","text":"<ol> <li>Load configuration (Spock) and validate basics.</li> <li>Discover plugins (Morpheus) from entry points and local folders.</li> <li>Register capabilities (embedders, repositories, hooks).</li> <li>Compose a pipeline in your app or via plugin hooks.</li> <li>Execute RAG workflows using the registries and hooks.</li> </ol> <p>This keeps the kernel stable while allowing your stack to evolve.</p>"},{"location":"rag2f/#how-to-extend-safely","title":"How to extend safely","text":"<ul> <li>Add embedders and repositories via plugins.</li> <li>Keep plugin dependencies scoped to the plugin folder.</li> <li>Use hooks for behavior composition; keep core untouched.</li> </ul>"},{"location":"rag2f/#quick-links","title":"Quick links","text":"<ul> <li>Quickstart</li> <li>Installation</li> <li>Configuration (Spock)</li> <li>Plugins &amp; hooks (Morpheus)</li> <li>Hooks reference</li> <li>Embedders (OptimusPrime)</li> <li>Repositories (XFiles)</li> <li>Architecture</li> <li>Troubleshooting</li> </ul>"},{"location":"rag2f/#license","title":"License","text":"<p>rag2f is distributed under GPL-3.0 (see the repository\u2019s <code>LICENSE</code>).</p>"},{"location":"rag2f/#get-in-touch","title":"Get in touch","text":"<p>If you\u2019re working on rag2f plugins or want to align on architecture, open a GitHub issue/discussion in the rag2f repo.</p>"},{"location":"rag2f/architecture/","title":"Architecture","text":"<p>rag2f is a kernel: it gives you the smallest stable set of components needed to compose RAG systems.</p> <p>Everything volatile lives outside the core \u2014 in plugins or your application.</p> <p>\"No disassemble!\" - Johnny 5, Short Circuit</p> <pre><code>  .-.\n [o_o]  Johnny5\n /| |\\  input\n</code></pre>"},{"location":"rag2f/architecture/#high-level-diagram","title":"High-level diagram","text":"<pre><code>               +-----------------------+\n               |   Your Application    |\n               +-----------+-----------+\n                           |\n                        RAG2F\n                           |\n        +------------------+------------------+\n        |                  |                  |\n      Spock             Morpheus          Johnny5\n (config manager)   (plugins &amp; hooks)  (input manager)\n        |                  |\n        |            +-----+--------------------------+\n        |            |                                |\n   OptimusPrime    entry points                  filesystem\n (embedder registry) (rag2f.plugins)             ./plugins\n        |\n      XFiles\n (repository registry)\n</code></pre>"},{"location":"rag2f/architecture/#what-lives-in-core-vs-plugins","title":"What lives in core vs plugins","text":""},{"location":"rag2f/architecture/#core-stable","title":"Core (stable)","text":"<ul> <li>configuration loader &amp; merger (Spock)</li> <li>plugin discovery and hook orchestration (Morpheus)</li> <li>registries (OptimusPrime, XFiles)</li> <li>protocols/contracts and validation</li> </ul>"},{"location":"rag2f/architecture/#plugins-volatile","title":"Plugins (volatile)","text":"<ul> <li>embedders (Azure OpenAI, OpenAI, local models, etc.)</li> <li>repositories (Postgres, SQLite, Qdrant, Pinecone, Neo4j, etc.)</li> <li>orchestration patterns (pipelines, workers, DAGs)</li> <li>application-specific behavior via hooks</li> </ul> <p>Plugins can ship their own dependencies so the kernel stays minimal and stable.</p>"},{"location":"rag2f/architecture/#naming-is-intentional","title":"Naming is intentional","text":"<p>The narrative names are constraints on design:</p> <ul> <li>registries/managers should stay small and predictable</li> <li>executors/orchestrators should live outside the kernel</li> </ul> <p>This helps prevent a \u201cgod object\u201d core.</p>"},{"location":"rag2f/architecture/#pipeline-philosophy","title":"Pipeline philosophy","text":"<p>rag2f does not impose a single \u201cretrieve \u2192 rerank \u2192 generate\u201d pipeline. Instead, you build pipelines by composing: - hooks - registries (get the embedder/repository you need) - your own application code</p>"},{"location":"rag2f/architecture/#startup-sequence","title":"Startup sequence","text":"<p>A typical startup flow looks like this:</p> <ol> <li>Spock loads configuration from JSON + env (env wins).</li> <li>Morpheus discovers plugins (entry points, then filesystem).</li> <li>Plugins register hooks and contribute embedders/repositories.</li> <li>Registries validate implementations and enforce contracts.</li> <li>Your app composes a pipeline with hooks and registry lookups.</li> </ol> <p>This order keeps configuration and discovery deterministic across environments.</p>"},{"location":"rag2f/architecture/#data-flow-conceptual","title":"Data flow (conceptual)","text":"<pre><code>Input -&gt; Johnny5 -&gt; hooks (preprocess/retrieve/rerank) -&gt; embedder/repo -&gt; response\n</code></pre> <p>Johnny5 accepts input, then Morpheus runs the hook pipeline. The pipeline uses registries to fetch embedders or repositories as needed.</p>"},{"location":"rag2f/architecture/#extension-points","title":"Extension points","text":"<p>Where you can extend rag2f safely:</p> <ul> <li>Plugins: add embedders and repositories without touching core.</li> <li>Hooks: compose multi-step pipelines (preprocess, retrieve, rerank, generate).</li> <li>Native handles: drop down to backend SDKs when needed.</li> </ul>"},{"location":"rag2f/architecture/#dependency-isolation","title":"Dependency isolation","text":"<p>Core dependencies are intentionally minimal. Heavy SDKs live in plugins, which means:</p> <ul> <li>faster base installs,</li> <li>smaller attack surface,</li> <li>backend-specific upgrades that do not destabilize the kernel.</li> </ul>"},{"location":"rag2f/architecture/#runtime-boundaries","title":"Runtime boundaries","text":"<p>The core does not:</p> <ul> <li>enforce a specific prompt format,</li> <li>provide a fixed agent loop,</li> <li>assume a specific vector database or LLM provider.</li> </ul> <p>This keeps the kernel stable and lets you build opinionated workflows in plugins or app code.</p>"},{"location":"rag2f/concepts/","title":"Concepts","text":"<p>This page defines the core terms used throughout the rag2f docs.</p>"},{"location":"rag2f/concepts/#kernel","title":"Kernel","text":"<p>The kernel is the small, stable core of rag2f. It only contains:</p> <ul> <li>configuration and plugin discovery</li> <li>registries and contracts</li> <li>hook orchestration</li> </ul> <p>Everything else should live in plugins or your application.</p>"},{"location":"rag2f/concepts/#instance","title":"Instance","text":"<p>An instance is a single <code>RAG2F</code> object with its own configuration, registries, and plugin state. Instances are intentionally isolated so tests, tenants, or apps can run side by side without cross-talk.</p>"},{"location":"rag2f/concepts/#plugin","title":"Plugin","text":"<p>A plugin is a self-contained integration that contributes hooks, embedders, repositories, or helpers. Plugins are discovered via Python entry points or a local <code>plugins/</code> folder.</p>"},{"location":"rag2f/concepts/#plugin-id","title":"Plugin ID","text":"<p>A plugin ID is the stable identifier used for namespacing config and avoiding collisions. It also becomes the namespace used in logs and hook registrations.</p>"},{"location":"rag2f/concepts/#hook","title":"Hook","text":"<p>A hook is a named pipeline stage. Multiple hooks can register for the same stage and are executed in priority order. Hooks optionally receive a pipeable payload called <code>phone</code> that flows through the pipeline.</p>"},{"location":"rag2f/concepts/#phone","title":"Phone","text":"<p>Phone is the pipeable payload that moves through a hook pipeline. It is typically a small dict or dataclass that each hook can enrich.</p>"},{"location":"rag2f/concepts/#registry","title":"Registry","text":"<p>Registries are named stores owned by the kernel:</p> <ul> <li>OptimusPrime stores embedders.</li> <li>XFiles stores repositories.</li> </ul> <p>Registries enforce basic contracts and protect against accidental overrides.</p>"},{"location":"rag2f/concepts/#protocol","title":"Protocol","text":"<p>A protocol is a minimal interface a plugin component must satisfy. rag2f uses protocols to validate embedders and repositories without prescribing full implementations.</p>"},{"location":"rag2f/concepts/#capability","title":"Capability","text":"<p>A capability is a feature flag declared by a repository to signal which operations it supports. This protects callers from invoking methods the backend does not implement.</p>"},{"location":"rag2f/concepts/#entry-point","title":"Entry point","text":"<p>An entry point is a packaging-time registration that lets Morpheus discover a plugin from installed packages. Entry points are resolved before filesystem plugins to keep discovery deterministic.</p>"},{"location":"rag2f/concepts/#native-escape-hatch","title":"Native escape hatch","text":"<p>The native escape hatch is a repository feature that exposes a backend-specific handle so you can access vendor-specific power without distorting the core contracts.</p>"},{"location":"rag2f/concepts/#pipeline","title":"Pipeline","text":"<p>A pipeline is the ordered composition of hooks and application logic that turns a user input into a response. rag2f does not define a default pipeline; you assemble one explicitly.</p>"},{"location":"rag2f/concepts/#result-pattern","title":"Result pattern","text":"<p>The Result pattern returns structured outcomes for expected states (empty input, missing repo, no results) instead of raising exceptions. See Result pattern for details and examples.</p>"},{"location":"rag2f/configuration/","title":"Configuration (Spock)","text":"<p>Spock is the centralized, instance-scoped configuration system for rag2f.</p> <p>It supports: - JSON config files for structured settings - Environment variables for secrets and overrides - Priority: env overrides JSON - Namespaced config for plugins and core settings - Type inference for env values (bools, numbers, JSON)</p> <p>\"The needs of the many outweigh the needs of the few.\" - Spock, Star Trek II: The Wrath of Khan</p> <pre><code>   /\\\n  /__\\   Spock\n  |..|   logic\n  |__|\n</code></pre>"},{"location":"rag2f/configuration/#config-file","title":"Config file","text":"<p>A typical config looks like:</p> <pre><code>{\n  \"rag2f\": {\n    \"embedder_default\": \"test_embedder\"\n  },\n  \"plugins\": {\n    \"azure_openai_embedder\": {\n      \"azure_endpoint\": \"https://your-resource.openai.azure.com\",\n      \"api_key\": \"your-api-key\",\n      \"api_version\": \"2024-02-15-preview\",\n      \"deployment\": \"text-embedding-ada-002\"\n    }\n  }\n}\n</code></pre>"},{"location":"rag2f/configuration/#loading-config","title":"Loading config","text":"<p>You can load config via:</p> <ul> <li><code>config_path=\"config.json\"</code> (Spock reads the file)</li> <li><code>config={...}</code> (pass a dict directly)</li> </ul> <p>rag2f loads configuration before discovering plugins:</p> <pre><code>rag2f = await RAG2F.create(config_path=\"config.json\")\n</code></pre>"},{"location":"rag2f/configuration/#precedence-rules","title":"Precedence rules","text":"<p>Spock merges configuration in a clear order (highest to lowest):</p> <ol> <li>Environment variables</li> <li>JSON config file</li> <li>Provided config dict (if any)</li> <li>Defaults</li> </ol> <p>This makes env a reliable override mechanism for secrets and per-env tweaks.</p>"},{"location":"rag2f/configuration/#environment-variables","title":"Environment variables","text":"<p>Environment variables override JSON values. Spock parses values as:</p> <ul> <li><code>true/false</code> \u2192 bool</li> <li>numbers \u2192 int/float</li> <li>JSON strings (objects/arrays) \u2192 parsed JSON</li> <li>otherwise \u2192 string</li> </ul>"},{"location":"rag2f/configuration/#environment-variable-naming","title":"Environment variable naming","text":"<pre><code>RAG2F__&lt;SECTION&gt;__&lt;KEY&gt;__&lt;SUBKEY&gt;...\n</code></pre> <ul> <li>Sections: <code>RAG2F</code> for core, <code>PLUGINS</code> for plugins</li> <li>Examples:</li> <li><code>RAG2F__RAG2F__EMBEDDER_DEFAULT=azure_openai</code></li> <li><code>RAG2F__PLUGINS__AZURE_OPENAI_EMBEDDER__API_KEY=sk-xxx</code></li> <li><code>RAG2F__PLUGINS__MY_PLUGIN__DATABASE__HOST=localhost</code></li> </ul>"},{"location":"rag2f/configuration/#namespacing-rules","title":"Namespacing rules","text":"<p>Use separate namespaces to avoid collisions:</p> <ul> <li>core: <code>rag2f.*</code></li> <li>plugins: <code>plugins.&lt;plugin_id&gt;.*</code></li> </ul> <p>Example:</p> <pre><code>{\n  \"rag2f\": {\n    \"embedder_default\": \"azure_openai\"\n  },\n  \"plugins\": {\n    \"azure_openai_embedder\": {\n      \"deployment\": \"text-embedding-3-large\"\n    }\n  }\n}\n</code></pre>"},{"location":"rag2f/configuration/#environment-override-patterns","title":"Environment override patterns","text":"<p>You can keep secrets in env and map them inside your plugin logic:</p> <pre><code>api_key = rag2f.spock.get(\"plugins.azure_openai_embedder.api_key\")\nif not api_key:\n    api_key = os.getenv(\"AZURE_OPENAI_API_KEY\")\n</code></pre> <p>This keeps config files safe for commits while still enabling per-environment overrides.</p>"},{"location":"rag2f/configuration/#accessing-config","title":"Accessing config","text":"<p>From the core (typed helpers):</p> <pre><code>default_embedder = rag2f.spock.get_rag2f_config(\"embedder_default\")\n</code></pre> <p>From plugins:</p> <pre><code>plugin_cfg = rag2f.spock.get_plugin_config(\"azure_openai_embedder\")\napi_key = plugin_cfg.get(\"api_key\")\n</code></pre>"},{"location":"rag2f/configuration/#recommended-patterns","title":"Recommended patterns","text":"<ul> <li>Put non-secrets in <code>config.json</code></li> <li>Put secrets in env (e.g. <code>AZURE_OPENAI_API_KEY</code>) and map them in your plugin logic</li> <li>Keep plugin config nested under <code>plugins.&lt;plugin_id&gt;</code></li> <li>Fail fast on missing required config in your plugin activation code</li> </ul>"},{"location":"rag2f/configuration/#troubleshooting-quick-checks","title":"Troubleshooting quick checks","text":"<ul> <li>Confirm Spock is loaded: <code>rag2f.spock.is_loaded</code></li> <li>Verify config file path: <code>rag2f.spock.config_path</code></li> </ul>"},{"location":"rag2f/configuration/#common-pitfalls","title":"Common pitfalls","text":"<ul> <li>Wrong section casing: env keys are normalized to lowercase; match IDs exactly.</li> <li>Missing plugin namespace: plugin config belongs under <code>plugins.&lt;plugin_id&gt;</code>.</li> <li>Accidental JSON strings: wrap JSON objects/arrays in env carefully to avoid parse errors.</li> </ul>"},{"location":"rag2f/embedders/","title":"Embedders (OptimusPrime)","text":"<p>OptimusPrime is the embedder registry.</p> <p>Embedders are contributed by plugins and must satisfy the <code>Embedder</code> protocol (structural typing / duck typing).</p> <p>\"Freedom is the right of all sentient beings.\" - Optimus Prime, Transformers</p> <pre><code> [====]\n | [] |  Optimus\n | || |  Prime\n [____]\n</code></pre>"},{"location":"rag2f/embedders/#the-embedder-protocol","title":"The <code>Embedder</code> protocol","text":"<p>An embedder must expose:</p> <ul> <li><code>size</code> (property): embedding vector length</li> <li><code>getEmbedding(text: str, normalize: bool = False) -&gt; list[float]</code></li> </ul> <p>Minimal example:</p> <pre><code>class MyEmbedder:\n    size = 3\n\n    def getEmbedding(self, text: str, normalize: bool = False) -&gt; list[float]:\n        vec = [0.1, 0.2, 0.3]\n        if normalize:\n            scale = sum(v * v for v in vec) ** 0.5\n            vec = [v / scale for v in vec]\n        return vec\n</code></pre>"},{"location":"rag2f/embedders/#registering-embedders","title":"Registering embedders","text":"<p>Plugins typically register an embedder instance with a name/id:</p> <pre><code># inside your plugin activation or hook\nrag2f.optimus_prime.register(\"my_embedder\", MyEmbedder(...))\n</code></pre> <p>OptimusPrime enforces protocol compliance and prevents accidental overrides.</p>"},{"location":"rag2f/embedders/#override-policy","title":"Override policy","text":"<ul> <li>Registering the same instance under the same key is allowed (idempotent).</li> <li>Registering a different instance under an existing key raises <code>ValueError</code>.</li> </ul> <p>This prevents accidental replacement of an embedder at runtime.</p>"},{"location":"rag2f/embedders/#batching-and-performance","title":"Batching and performance","text":"<p>If your backend supports batch embedding, consider exposing a second helper method in your plugin module (not the protocol) and wrap it with a hook. This keeps the core contract simple while letting you optimize for throughput.</p>"},{"location":"rag2f/embedders/#selecting-the-default-embedder","title":"Selecting the default embedder","text":"<p>Default embedder selection uses Spock config:</p> <ul> <li><code>rag2f.embedder_default = \"&lt;name&gt;\"</code></li> </ul> <p>If exactly one embedder is registered, rag2f may treat it as default automatically. If multiple embedders are registered and no default is configured, <code>get_default()</code> raises a <code>LookupError</code>.</p> <p>Usage:</p> <pre><code>embedder = rag2f.optimus_prime.get_default()\nvec = embedder.getEmbedding(\"hello\")\n</code></pre>"},{"location":"rag2f/embedders/#normalization","title":"Normalization","text":"<p>If you implement <code>normalize=True</code>, document whether you: - L2-normalize vectors, - or apply another scaling/standardization.</p> <p>Downstream vector search engines often expect normalized embeddings for cosine similarity.</p>"},{"location":"rag2f/embedders/#registry-inspection","title":"Registry inspection","text":"<p>You can inspect the registry for debugging:</p> <pre><code>rag2f.optimus_prime.list_keys()\nrag2f.optimus_prime.has(\"my_embedder\")\n</code></pre>"},{"location":"rag2f/hooks-reference/","title":"Hooks reference","text":"<p>This page collects the practical details of how hooks behave.</p>"},{"location":"rag2f/hooks-reference/#signatures","title":"Signatures","text":"<p>Hooks are plain Python callables decorated with <code>@hook</code>.</p> <p>Pipeable hook:</p> <pre><code>@hook(\"preprocess\", priority=5)\ndef preprocess(phone, *, rag2f):\n    phone[\"text\"] = phone[\"text\"].strip()\n    return phone\n</code></pre> <p>Side-effect hook:</p> <pre><code>@hook(\"startup\", priority=1)\ndef startup(*, rag2f):\n    rag2f.logger.info(\"Ready\")\n</code></pre>"},{"location":"rag2f/hooks-reference/#piping-behavior","title":"Piping behavior","text":"<ul> <li>If the hook takes at least one positional argument, the first is treated as <code>phone</code>.</li> <li>The return value becomes the input for the next hook.</li> <li>If a hook returns <code>None</code>, the pipeline stops with <code>None</code> unless you handle it explicitly.</li> </ul>"},{"location":"rag2f/hooks-reference/#guarding-against-none","title":"Guarding against <code>None</code>","text":"<p>If you want to allow soft-fail behavior, use a sentinel:</p> <pre><code>phone = rag2f.morpheus.execute_hook(\"retrieve\", phone, rag2f=rag2f) or phone\n</code></pre>"},{"location":"rag2f/hooks-reference/#ordering","title":"Ordering","text":"<p>Hooks with higher priority run earlier. If priorities are equal, ordering is deterministic but unspecified. Use priorities to guarantee ordering across plugins.</p>"},{"location":"rag2f/hooks-reference/#testing-hooks","title":"Testing hooks","text":"<p>Because hooks are plain functions, you can unit test them directly:</p> <pre><code>def test_preprocess():\n    phone = {\"text\": \"  hi  \"}\n    assert preprocess(phone, rag2f=FakeRag2f())[\"text\"] == \"hi\"\n</code></pre> <p>Keep hook logic small and push side-effectful work into helpers so tests remain fast.</p>"},{"location":"rag2f/hooks/","title":"Hooks","text":"<p>Hooks are rag2f\u2019s main extension point. They are \u201cadaptation points\u201d that let plugins modify behavior without changing the core.</p>"},{"location":"rag2f/hooks/#the-phone-pattern-pipeable-value","title":"The <code>phone</code> pattern (pipeable value)","text":"<p>For hook pipelines that accept arguments, Morpheus treats the first positional argument as a pipeable payload called phone:</p> <ul> <li>hook 1 receives <code>phone</code>, returns a (possibly modified) <code>phone</code></li> <li>hook 2 receives the returned <code>phone</code>, and so on</li> </ul> <p>This lets you: - add capabilities - override defaults - enrich results</p> <p>Keep <code>phone</code> a dictionary or small dataclass to make composition predictable.</p>"},{"location":"rag2f/hooks/#example-pipeline-conceptual","title":"Example pipeline (conceptual)","text":"<pre><code>phone = {\"text\": \"Hello\"}\nphone = rag2f.morpheus.execute_hook(\"preprocess\", phone, rag2f=rag2f)\nphone = rag2f.morpheus.execute_hook(\"retrieve\", phone, rag2f=rag2f)\nphone = rag2f.morpheus.execute_hook(\"rerank\", phone, rag2f=rag2f)\nphone = rag2f.morpheus.execute_hook(\"generate\", phone, rag2f=rag2f)\n</code></pre>"},{"location":"rag2f/hooks/#defining-a-hook","title":"Defining a hook","text":"<pre><code>from rag2f.core.morpheus.decorators.hook import hook\n\n@hook(\"preprocess\", priority=5)\ndef preprocess(phone, *, rag2f):\n    phone[\"text\"] = phone[\"text\"].strip()\n    return phone\n</code></pre>"},{"location":"rag2f/hooks/#priorities","title":"Priorities","text":"<ul> <li>Default priority is <code>1</code></li> <li>Higher priority runs earlier</li> </ul> <p>If multiple plugins define the same hook, the ordering is deterministic by priority.</p>"},{"location":"rag2f/hooks/#hook-naming","title":"Hook naming","text":"<p>Use short, intention-revealing names for hooks:</p> <ul> <li><code>preprocess</code></li> <li><code>retrieve</code></li> <li><code>rerank</code></li> <li><code>generate</code></li> </ul> <p>Avoid embedding backend details in hook names; keep those in plugin IDs.</p>"},{"location":"rag2f/hooks/#executing-a-hook","title":"Executing a hook","text":"<p>From the core / your application:</p> <pre><code>phone = {\"text\": \"  hello  \"}\nphone = rag2f.morpheus.execute_hook(\"preprocess\", phone, rag2f=rag2f)\n</code></pre> <p>If no plugin implements the hook: - if a phone argument was provided, Morpheus returns it unchanged - otherwise it returns <code>None</code></p>"},{"location":"rag2f/hooks/#when-to-use-hooks-vs-plugins","title":"When to use hooks vs plugins","text":"<ul> <li>Use hooks when you want to compose behaviors (pipelines).</li> <li>Use plugin overrides (<code>@plugin</code>) when you want to override plugin-specific behavior (non-piped, per-plugin).</li> </ul>"},{"location":"rag2f/hooks/#error-handling","title":"Error handling","text":"<p>Hooks should raise errors that are meaningful to callers. If you need a soft-fail behavior, return a sentinel in <code>phone</code> and let downstream hooks decide.</p>"},{"location":"rag2f/hooks/#design-tips","title":"Design tips","text":"<ul> <li>Keep hooks small and focused; push heavy logic into helpers.</li> <li>Prefer additive changes to <code>phone</code> over destructive rewrites.</li> <li>Document any required <code>phone</code> keys in your plugin README.</li> </ul>"},{"location":"rag2f/installation/","title":"Installation","text":""},{"location":"rag2f/installation/#requirements","title":"Requirements","text":"<ul> <li>Python 3.12+ (rag2f declares <code>requires-python = \"&gt;=3.12\"</code>)</li> <li>A Dev Container (recommended for consistent toolchains)</li> </ul>"},{"location":"rag2f/installation/#install-from-source-dev","title":"Install from source (dev)","text":"<pre><code>git clone &lt;your-rag2f-repo&gt;\ncd rag2f\n# Recommended: Dev Container (VS Code / devcontainers CLI)\n# - Open the repo in the dev container and wait for the container to build\npip install -e \".[dev]\"\n</code></pre> <p>(If you prefer a local venv instead of a dev container: <code>python -m venv .venv &amp;&amp; source .venv/bin/activate</code>.)</p>"},{"location":"rag2f/installation/#dev-container-notes","title":"Dev Container notes","text":"<ul> <li>The container runs the same bootstrap script as local setup.</li> <li>You still get a <code>.venv</code> inside the workspace for consistent tooling.</li> <li>Use it for deterministic Python versions and tooling across the team.</li> </ul> <p>Alternatively, the repo ships a bootstrap script:</p> <pre><code>bash scripts/bootstrap-venv.sh\nsource .venv/bin/activate\n</code></pre>"},{"location":"rag2f/installation/#install-as-a-dependency","title":"Install as a dependency","text":"<p>If you publish rag2f to an index, install it like any other Python package:</p> <pre><code>pip install rag2f\n</code></pre>"},{"location":"rag2f/installation/#optional-extras","title":"Optional extras","text":"<p>rag2f keeps the core small, so most heavy dependencies live in plugins. Install plugin packages separately, or include them in your own app.</p>"},{"location":"rag2f/installation/#pinning-and-upgrades","title":"Pinning and upgrades","text":"<p>Because rag2f is designed to keep integrations in plugins, the core can remain small and stable. Still, for production systems:</p> <ul> <li>Pin rag2f and plugin versions together.</li> <li>Upgrade in a staging environment where you can validate the plugin contracts.</li> <li>Keep plugin dependencies isolated to avoid cross-plugin conflicts.</li> </ul>"},{"location":"rag2f/installation/#recommended-versioning-practice","title":"Recommended versioning practice","text":"<ul> <li>Pin <code>rag2f</code> and plugin packages in the same requirements lock.</li> <li>Record the <code>rag2f</code> version that each plugin was last tested with.</li> <li>Use CI to run plugin contract tests against new core versions.</li> </ul>"},{"location":"rag2f/installation/#project-layout-expectations","title":"Project layout expectations","text":"<p>rag2f assumes a \u201cproject root\u201d (current working directory) and uses it to locate a default plugin folder:</p> <ul> <li>default plugins folder: <code>./plugins</code> (relative to <code>os.getcwd()</code>)</li> </ul> <p>You can override this by passing <code>plugins_folder=...</code> when creating the <code>RAG2F</code> instance.</p>"},{"location":"rag2f/installation/#cli-scripts","title":"CLI / scripts","text":"<p>If your app has a CLI entry point, make sure it sets the working directory to the project root or passes an explicit <code>plugins_folder</code> so local plugins are consistently resolved.</p>"},{"location":"rag2f/installation/#local-plugins-folder","title":"Local plugins folder","text":"<p>For local development, create:</p> <pre><code>your_app/\n  config.json\n  plugins/\n    my_plugin/\n      plugin.json\n      my_plugin.py\n</code></pre> <p>Then:</p> <pre><code>rag2f = await RAG2F.create(plugins_folder=\"plugins\", config_path=\"config.json\")\n</code></pre>"},{"location":"rag2f/installation/#environment-variables","title":"Environment variables","text":"<p>Spock reads env vars with the <code>RAG2F__</code> prefix:</p> <pre><code>RAG2F__RAG2F__EMBEDDER_DEFAULT=my_embedder\nRAG2F__PLUGINS__MY_PLUGIN__API_KEY=sk-...\n</code></pre> <p>Env overrides config files, so it is the best place for secrets.</p>"},{"location":"rag2f/installation/#troubleshooting","title":"Troubleshooting","text":""},{"location":"rag2f/installation/#no-plugins-loaded","title":"\u201cNo plugins loaded\u201d","text":"<ul> <li>Ensure your <code>plugins_folder</code> exists (or that you installed plugins via pip with entry points).</li> <li>Check that each plugin has metadata (<code>plugin.json</code> and/or <code>pyproject.toml</code>) and Python files that define hooks/tools.</li> </ul>"},{"location":"rag2f/installation/#entry-point-plugin-path-returned-site-packages","title":"\u201cEntry point plugin path returned site-packages\u201d","text":"<p>Some plugins may accidentally return the <code>site-packages</code> directory instead of their own plugin directory. rag2f tries to detect and recover from this, but the plugin should fix its <code>get_plugin_path()</code> factory.</p>"},{"location":"rag2f/installation/#multiple-embedders-registered-but-no-default-configured","title":"\u201cMultiple embedders registered but no default configured\u201d","text":"<ul> <li>Set <code>rag2f.embedder_default</code> in config or env.</li> <li>If only one embedder is expected, ensure only that plugin is installed.</li> </ul>"},{"location":"rag2f/plugin-anatomy/","title":"Plugin anatomy","text":"<p>This page describes the recommended structure and metadata for rag2f plugins.</p>"},{"location":"rag2f/plugin-anatomy/#local-plugin-structure","title":"Local plugin structure","text":"<pre><code>plugins/\n  my_plugin/\n    plugin.json\n    my_plugin.py\n    README.md\n</code></pre> <p><code>plugin.json</code> is the primary metadata source.</p>"},{"location":"rag2f/plugin-anatomy/#extended-layout-recommended","title":"Extended layout (recommended)","text":"<pre><code>plugins/\n  my_plugin/\n    plugin.json\n    my_plugin.py\n    requirements.txt\n    README.md\n    tests/\n      test_plugin.py\n</code></pre> <p>Keep optional dependencies in <code>requirements.txt</code> so the core stays lean.</p>"},{"location":"rag2f/plugin-anatomy/#pluginjson-fields","title":"<code>plugin.json</code> fields","text":"<p>Minimal fields:</p> <ul> <li><code>id</code>: unique plugin id (used for config namespacing)</li> <li><code>name</code>: human-friendly name</li> <li><code>version</code>: plugin version</li> <li><code>module</code>: entry module path (relative to plugin folder)</li> </ul> <p>Example:</p> <pre><code>{\n  \"id\": \"my_plugin\",\n  \"name\": \"My Plugin\",\n  \"version\": \"0.1.0\",\n  \"module\": \"my_plugin.py\"\n}\n</code></pre>"},{"location":"rag2f/plugin-anatomy/#common-optional-fields","title":"Common optional fields","text":"<ul> <li><code>description</code>, <code>keywords</code></li> <li><code>author_name</code>, <code>author_email</code></li> <li><code>license</code></li> <li><code>urls</code> (project/home/docs)</li> <li><code>min_rag2f_version</code>, <code>max_rag2f_version</code></li> </ul> <p>Use <code>min_rag2f_version</code> to declare compatibility windows.</p>"},{"location":"rag2f/plugin-anatomy/#packaged-plugins-and-entry-points","title":"Packaged plugins and entry points","text":"<p>If you publish a plugin as a Python package, expose an entry point in the group:</p> <pre><code>rag2f.plugins\n</code></pre> <p>Entry points must be callable and must return the absolute path to the plugin folder.</p> <p>Conceptual <code>pyproject.toml</code> snippet:</p> <pre><code>[project.entry-points.\"rag2f.plugins\"]\nmy-plugin = \"my_plugin_pkg:get_plugin_path\"\n</code></pre>"},{"location":"rag2f/plugin-anatomy/#example-get_plugin_path","title":"Example <code>get_plugin_path()</code>","text":"<pre><code>from importlib import resources\n\ndef get_plugin_path() -&gt; str:\n    return str(resources.files(\"my_plugin_pkg\"))\n</code></pre>"},{"location":"rag2f/plugin-anatomy/#plugin-activation-checklist","title":"Plugin activation checklist","text":"<p>In your plugin module:</p> <ol> <li>Validate required config (fail fast).</li> <li>Register embedders or repositories with their registries.</li> <li>Register hooks for pipeline stages you want to contribute to.</li> </ol> <p>Keep heavy imports inside functions when possible so optional dependencies do not slow startup.</p>"},{"location":"rag2f/plugin-anatomy/#example-embedder-plugin-skeleton","title":"Example: embedder plugin skeleton","text":"<pre><code>from rag2f.core.morpheus.decorators.plugin import plugin\n\n@plugin\ndef activate(rag2f):\n    cfg = rag2f.spock.get_plugin_config(\"my_embedder\") or {}\n    api_key = cfg.get(\"api_key\")\n    if not api_key:\n        raise ValueError(\"Missing my_embedder.api_key\")\n    rag2f.optimus_prime.register(\"my_embedder\", MyEmbedder(api_key=api_key))\n</code></pre>"},{"location":"rag2f/plugin-anatomy/#example-repository-plugin-skeleton","title":"Example: repository plugin skeleton","text":"<pre><code>from rag2f.core.morpheus.decorators.plugin import plugin\n\n@plugin\ndef activate(rag2f):\n    repo = MyRepo(...)\n    result = rag2f.xfiles.execute_register(\n        \"primary\",\n        repo,\n        meta={\"type\": \"vector\", \"domain\": \"docs\"},\n    )\n    if result.is_error():\n        raise ValueError(result.detail.message)\n</code></pre>"},{"location":"rag2f/plugin-anatomy/#hook-design-tips","title":"Hook design tips","text":"<ul> <li>Keep hooks pure and deterministic where possible.</li> <li>Document expected <code>phone</code> keys in the plugin README.</li> <li>Use priorities to control ordering across plugins.</li> </ul>"},{"location":"rag2f/plugin-anatomy/#testing-suggestions","title":"Testing suggestions","text":"<ul> <li>Unit test hooks directly (they are plain functions).</li> <li>Validate registry entries and capability declarations.</li> <li>Run a smoke test that loads the plugin and calls a hook.</li> </ul>"},{"location":"rag2f/plugins/","title":"Plugins &amp; hooks (Morpheus)","text":"<p>Morpheus is the plugin manager. It discovers plugins, loads them, and executes hook pipelines.</p> <p>\"You take the red pill, you stay in Wonderland.\" - Morpheus, The Matrix</p> <pre><code>  ____\n / __ \\  Morpheus\n \\_\\_\\_\\  pill\n</code></pre>"},{"location":"rag2f/plugins/#discovery-model","title":"Discovery model","text":"<p>rag2f discovers plugins in two places (in this precedence order):</p> <ol> <li>Python entry points (installed packages)</li> <li>Filesystem plugins folder (local development)</li> </ol> <p>Entry points win over filesystem to prevent ambiguity (an installed plugin overrides a local plugin with the same id).</p>"},{"location":"rag2f/plugins/#entry-points","title":"Entry points","text":"<p>Plugins can be published as Python packages and expose an entry point in the group:</p> <ul> <li><code>rag2f.plugins</code></li> </ul> <p>The entry point must be callable and must return a string path to the plugin directory.</p> <p>Conceptual <code>pyproject.toml</code> snippet (in the plugin package):</p> <pre><code>[project.entry-points.\"rag2f.plugins\"]\nrag2f-azure-openai-embedder = \"rag2f_azure_openai_embedder:get_plugin_path\"\n</code></pre> <p>Where <code>get_plugin_path()</code> returns the on-disk folder that contains your <code>plugin.json</code> and plugin code.</p>"},{"location":"rag2f/plugins/#filesystem-plugins","title":"Filesystem plugins","text":"<p>For local development, Morpheus loads plugins from:</p> <ul> <li><code>plugins_folder</code> passed to <code>RAG2F.create(...)</code>, or</li> <li>default <code>./plugins</code></li> </ul>"},{"location":"rag2f/plugins/#plugin-metadata","title":"Plugin metadata","text":"<p>A plugin can define metadata via: - <code>plugin.json</code> (preferred) - <code>pyproject.toml</code> (can override/augment) - <code>requirements.txt</code> (optional; for plugin-scoped deps)</p> <p>rag2f merges metadata with a precedence model so you can ship packaged plugins and still support local dev.</p>"},{"location":"rag2f/plugins/#manifest-merge-and-defaults","title":"Manifest merge and defaults","text":"<ul> <li>Root-level <code>plugin.json</code> wins over nested manifests.</li> <li><code>pyproject.toml</code> can augment fields like name, description, and URLs.</li> <li>If no name is provided, rag2f derives a humanized name from the plugin id.</li> </ul>"},{"location":"rag2f/plugins/#plugin-id-and-config-namespace","title":"Plugin ID and config namespace","text":"<p>The plugin <code>id</code> is the stable identifier used for:</p> <ul> <li>config namespace: <code>plugins.&lt;plugin_id&gt;</code></li> <li>hook ownership and logging</li> <li>avoiding collisions between plugins</li> </ul> <p>Use a short, lowercase id (e.g. <code>azure_openai_embedder</code>).</p>"},{"location":"rag2f/plugins/#minimal-pluginjson","title":"Minimal <code>plugin.json</code>","text":"<pre><code>{\n  \"id\": \"hello_plugin\",\n  \"name\": \"Hello Plugin\",\n  \"version\": \"0.1.0\",\n  \"module\": \"hello_plugin.py\"\n}\n</code></pre> <p>Common optional fields:</p> <ul> <li><code>description</code>, <code>license</code>, <code>keywords</code></li> <li><code>author_name</code>, <code>author_email</code></li> <li><code>urls</code> (project/home/docs)</li> <li><code>min_rag2f_version</code>, <code>max_rag2f_version</code></li> </ul>"},{"location":"rag2f/plugins/#suggested-folder-layout","title":"Suggested folder layout","text":"<pre><code>plugins/\n  hello_plugin/\n    plugin.json\n    hello_plugin.py\n    README.md\n</code></pre> <p>If your plugin is packaged, the entry point should return the folder that contains <code>plugin.json</code>.</p>"},{"location":"rag2f/plugins/#plugin-scoped-dependencies","title":"Plugin-scoped dependencies","text":"<p>Plugins can ship their own dependencies via a local <code>requirements.txt</code>. Morpheus installs those requirements on activation so the core stays lean and plugins stay isolated.</p>"},{"location":"rag2f/plugins/#dependency-guidelines","title":"Dependency guidelines","text":"<ul> <li>Keep heavy SDKs in plugins, not core.</li> <li>Avoid importing optional dependencies at module import time.</li> <li>Validate config before initializing expensive clients.</li> </ul>"},{"location":"rag2f/plugins/#writing-hooks","title":"Writing hooks","text":"<p>A hook is a Python function decorated with <code>@hook</code>.</p> <pre><code>from rag2f.core.morpheus.decorators.hook import hook\n\n@hook(\"search\", priority=10)\ndef my_search_hook(phone, *, rag2f):\n    # phone is the \u201cpipe\u201d value that flows through hooks\n    phone[\"results\"].append(\"hello\")\n    return phone\n</code></pre>"},{"location":"rag2f/plugins/#hook-piping-model","title":"Hook piping model","text":"<p>If a hook takes at least one argument, Morpheus will pipe the first argument (<code>phone</code>) through all registered hook functions in priority order.</p> <p>If a hook takes no arguments (besides <code>rag2f</code>), it runs for side effects.</p> <p>See Hooks for details.</p>"},{"location":"rag2f/plugins/#plugin-activation-patterns","title":"Plugin activation patterns","text":"<p>Common plugin patterns:</p> <ul> <li>Register resources: add embedders or repositories during plugin initialization.</li> <li>Expose hooks: define <code>@hook</code> functions to compose behavior.</li> <li>Validate config: fail fast if required config is missing.</li> </ul> <p>Keep plugin modules focused; avoid importing heavy dependencies at import time if they are optional.</p>"},{"location":"rag2f/plugins/#lifecycle-overrides","title":"Lifecycle overrides","text":"<p>Use the <code>@plugin</code> decorator for lifecycle overrides (activation/deactivation) when you need to run setup or cleanup logic tied to the plugin itself.</p>"},{"location":"rag2f/plugins/#entry-point-troubleshooting","title":"Entry point troubleshooting","text":"<p>If an entry point returns the wrong path (e.g. <code>site-packages/</code>), the plugin will not load. Ensure your <code>get_plugin_path()</code> returns the folder containing <code>plugin.json</code>.</p>"},{"location":"rag2f/plugins/#refreshing-plugins","title":"Refreshing plugins","text":"<p>Morpheus supports cache refresh and will notify other components via callbacks when a refresh happens. This is useful in dev workflows when you are iterating on local plugins.</p>"},{"location":"rag2f/quickstart/","title":"Quickstart","text":"<p>This page shows the smallest \u201chello world\u201d you can run with rag2f.</p>"},{"location":"rag2f/quickstart/#1-install","title":"1) Install","text":"<pre><code># Recommended: Dev Container (VS Code / devcontainers CLI)\n# - Open the repo in the dev container and wait for the container to build\npip install -e .\n</code></pre> <p>(If you prefer a local venv instead of a dev container: <code>python -m venv .venv &amp;&amp; source .venv/bin/activate</code>.)</p>"},{"location":"rag2f/quickstart/#2-create-a-config-optional","title":"2) Create a config (optional)","text":"<p>rag2f can run with an empty config, but most real usage needs at least an embedder and one repository.</p> <p>Create <code>config.json</code>:</p> <pre><code>{\n  \"rag2f\": {\n    \"embedder_default\": \"my_embedder\"\n  },\n  \"plugins\": {\n    \"my_embedder_plugin\": {\n      \"api_key\": \"...\"\n    }\n  }\n}\n</code></pre>"},{"location":"rag2f/quickstart/#3-add-a-tiny-local-plugin-optional","title":"3) Add a tiny local plugin (optional)","text":"<p>Local plugins are the fastest way to test hooks and registries.</p> <p>Create a plugin folder:</p> <pre><code>plugins/\n  hello_plugin/\n    plugin.json\n    hello_plugin.py\n</code></pre> <p>Example <code>plugin.json</code>:</p> <pre><code>{\n  \"id\": \"hello_plugin\",\n  \"name\": \"Hello Plugin\",\n  \"version\": \"0.1.0\",\n  \"module\": \"hello_plugin.py\"\n}\n</code></pre> <p>Example <code>hello_plugin.py</code>:</p> <pre><code>from rag2f.core.morpheus.decorators.hook import hook\n\n@hook(\"preprocess\", priority=5)\ndef add_tag(phone, *, rag2f):\n    phone[\"tags\"] = phone.get(\"tags\", []) + [\"hello\"]\n    return phone\n</code></pre>"},{"location":"rag2f/quickstart/#4-start-an-instance-and-discover-plugins","title":"4) Start an instance and discover plugins","text":"<pre><code>import asyncio\nfrom rag2f.core.rag2f import RAG2F\n\nasync def main():\n    rag2f = await RAG2F.create(\n        plugins_folder=\"plugins/\",    # optional; defaults to ./plugins\n        config_path=\"config.json\",    # optional\n    )\n\n    # Embedder\n    embedder = rag2f.optimus_prime.get_default()\n    v = embedder.getEmbedding(\"hello rag2f\")\n\n    print(len(v), v[:5])\n\nasyncio.run(main())\n</code></pre>"},{"location":"rag2f/quickstart/#5-compose-a-minimal-pipeline","title":"5) Compose a minimal pipeline","text":"<p>rag2f does not impose a pipeline; you compose one with hooks and registries:</p> <pre><code>phone = {\"text\": \"hello rag2f\"}\nphone = rag2f.morpheus.execute_hook(\"preprocess\", phone, rag2f=rag2f)\nphone = rag2f.morpheus.execute_hook(\"retrieve\", phone, rag2f=rag2f)\nphone = rag2f.morpheus.execute_hook(\"rerank\", phone, rag2f=rag2f)\nphone = rag2f.morpheus.execute_hook(\"generate\", phone, rag2f=rag2f)\n</code></pre> <p>Hooks are optional. If no plugin implements a hook, the phone passes through unchanged.</p>"},{"location":"rag2f/quickstart/#6-use-repositories-xfiles","title":"6) Use repositories (XFiles)","text":"<p>Once a repository plugin is registered, you can fetch it by name/id and call protocol methods based on capabilities.</p> <p>Conceptually:</p> <pre><code>repo_result = rag2f.xfiles.execute_get(\"primary\")\nif not repo_result.is_ok() or not repo_result.repository:\n    raise LookupError(\"Repository 'primary' not found\")\nrepo = repo_result.repository\n\n# Minimal CRUD\nawait repo.insert({\"id\": \"1\", \"text\": \"hello\"})\n\n# Optional query / vector search if supported by the repository\nrows = await repo.find({\"where\": {\"field\": \"text\", \"op\": \"contains\", \"value\": \"hello\"}})\n</code></pre> <p>See Repositories (XFiles) for the real contracts and <code>QuerySpec</code> shapes.</p>"},{"location":"rag2f/quickstart/#example-walkthrough-tiny-in-memory-notes-rag","title":"Example walkthrough: tiny in-memory \"notes RAG\"","text":"<p>This walkthrough is fully local (no external APIs) and touches the main pieces: plugins, embedders, repositories, and a hook-based retrieval step. You can run it end-to-end to verify the repo works on your machine.</p>"},{"location":"rag2f/quickstart/#1-create-a-local-demo-plugin","title":"1) Create a local demo plugin","text":"<pre><code>plugins/\n  tiny_demo/\n    plugin.json\n    tiny_demo.py\n</code></pre> <p><code>plugins/tiny_demo/plugin.json</code>:</p> <pre><code>{\n  \"id\": \"tiny_demo\",\n  \"name\": \"Tiny Demo Plugin\",\n  \"version\": \"0.1.0\",\n  \"module\": \"tiny_demo.py\"\n}\n</code></pre> <p><code>plugins/tiny_demo/tiny_demo.py</code>:</p> <pre><code>from rag2f.core.morpheus.decorators import hook, plugin\nfrom rag2f.core.xfiles import BaseRepository, minimal_crud_capabilities\n\n\nclass InMemoryRepo(BaseRepository):\n    def __init__(self, name=\"tiny_repo\"):\n        self._name = name\n        self._rows = {}\n\n    @property\n    def name(self) -&gt; str:\n        return self._name\n\n    def capabilities(self):\n        return minimal_crud_capabilities()\n\n    def get(self, id, select=None):\n        return self._rows[id]\n\n    def insert(self, id, item):\n        self._rows[id] = item\n\n    def update(self, id, patch):\n        self._rows[id] = {**self._rows[id], **patch}\n\n    def delete(self, id):\n        self._rows.pop(id, None)\n\n    def all(self):\n        return list(self._rows.values())\n\n    def _get_native_handle(self, kind: str):\n        raise NotImplementedError(\"Native handles not supported in this demo\")\n\n\nclass TinyEmbedder:\n    \"\"\"Toy embedder for the demo: keyword presence vector.\"\"\"\n\n    _keys = (\"password\", \"refund\", \"hours\")\n\n    @property\n    def size(self) -&gt; int:\n        return len(self._keys)\n\n    def getEmbedding(self, text: str, *, normalize: bool = False):\n        text = text.lower()\n        vec = [1.0 if key in text else 0.0 for key in self._keys]\n        if normalize:\n            norm = (sum(v * v for v in vec) ** 0.5) or 1.0\n            vec = [v / norm for v in vec]\n        return vec\n\n\n@plugin\ndef activated(plugin, rag2f):\n    \"\"\"Lifecycle hook: register the demo embedder + repo.\"\"\"\n    if not rag2f.optimus_prime.has(\"tiny_embedder\"):\n        rag2f.optimus_prime.register(\"tiny_embedder\", TinyEmbedder())\n\n    if not rag2f.xfiles.has(\"tiny_repo\"):\n        result = rag2f.xfiles.execute_register(\n            \"tiny_repo\",\n            InMemoryRepo(),\n            meta={\"type\": \"memory\", \"domain\": \"demo\"},\n        )\n        if result.is_error():\n            raise RuntimeError(result.detail.message)\n\n\n@hook(\"retrieve\", priority=10)\ndef retrieve(phone, *, rag2f):\n    \"\"\"Naive retrieval: cosine over keyword vectors.\"\"\"\n    repo_result = rag2f.xfiles.execute_get(\"tiny_repo\")\n    repo = repo_result.repository if repo_result.is_ok() else None\n    embedder = rag2f.optimus_prime.get(\"tiny_embedder\")\n    if repo is None or embedder is None:\n        return phone\n\n    query_vec = embedder.getEmbedding(phone[\"query\"], normalize=True)\n    results = []\n    for row in repo.all():\n        score = sum(a * b for a, b in zip(query_vec, row[\"embedding\"], strict=False))\n        results.append({\"id\": row[\"id\"], \"text\": row[\"text\"], \"score\": score})\n\n    results.sort(key=lambda r: r[\"score\"], reverse=True)\n    phone[\"results\"] = results[: phone.get(\"top_k\", 3)]\n    return phone\n</code></pre> <p>Note: the lifecycle function must be named <code>activated</code> to run on plugin load.</p>"},{"location":"rag2f/quickstart/#2-create-a-runnable-script","title":"2) Create a runnable script","text":"<p><code>examples/tiny_demo.py</code>:</p> <pre><code>import asyncio\nfrom rag2f.core.rag2f import RAG2F\n\n\nasync def main():\n    rag2f = await RAG2F.create(plugins_folder=\"plugins/\")\n\n    repo_result = rag2f.xfiles.execute_get(\"tiny_repo\")\n    repo = repo_result.repository if repo_result.is_ok() else None\n    embedder = rag2f.optimus_prime.get(\"tiny_embedder\")\n    if repo is None or embedder is None:\n        raise RuntimeError(\"Demo plugin did not load\")\n\n    docs = {\n        \"pwd_reset\": \"Reset your password in the account settings.\",\n        \"refund_policy\": \"Refunds are available within 30 days.\",\n        \"support_hours\": \"Support hours are Mon-Fri 9-5.\",\n    }\n\n    for doc_id, text in docs.items():\n        repo.insert(\n            doc_id,\n            {\n                \"id\": doc_id,\n                \"text\": text,\n                \"embedding\": embedder.getEmbedding(text, normalize=True),\n            },\n        )\n\n    phone = {\"query\": \"I forgot my password\", \"top_k\": 2}\n    phone = rag2f.morpheus.execute_hook(\"retrieve\", phone, rag2f=rag2f)\n\n    for hit in phone[\"results\"]:\n        print(f\"{hit['id']} (score={hit['score']:.2f}): {hit['text']}\")\n\n\nasyncio.run(main())\n</code></pre>"},{"location":"rag2f/quickstart/#3-run-it","title":"3) Run it","text":"<pre><code>python examples/tiny_demo.py\n</code></pre> <p>Expected: <code>pwd_reset</code> should be the top hit (score ~1.00).</p>"},{"location":"rag2f/quickstart/#7-add-a-simple-repository-plugin-sketch","title":"7) Add a simple repository plugin (sketch)","text":"<p>Repository plugins register themselves in activation or via hooks:</p> <pre><code>from rag2f.core.xfiles import BaseRepository\n\nclass MemoryRepo(BaseRepository):\n    capabilities = {\"queryable\": False, \"vector_search\": False, \"graph_traversal\": False}\n    def __init__(self):\n        self._rows = {}\n    def insert(self, data):\n        self._rows[data[\"id\"]] = data\n    def get(self, id):\n        return self._rows.get(id)\n    def update(self, id, data):\n        self._rows[id] = {**self._rows.get(id, {}), **data}\n    def delete(self, id):\n        self._rows.pop(id, None)\n\ndef activate(rag2f):\n    result = rag2f.xfiles.execute_register(\n        \"memory\",\n        MemoryRepo(),\n        meta={\"type\": \"memory\", \"domain\": \"demo\"},\n    )\n    if result.is_error():\n        raise ValueError(result.detail.message)\n</code></pre>"},{"location":"rag2f/quickstart/#8-add-a-track-id-for-idempotency","title":"8) Add a track ID for idempotency","text":"<p>If your input pipeline needs idempotency or tracing, include a track ID in your phone payload and let downstream hooks keep it attached to results:</p> <pre><code>import uuid\nphone = {\"id\": uuid.uuid4().hex, \"text\": \"hello rag2f\"}\n</code></pre>"},{"location":"rag2f/quickstart/#next-steps","title":"Next steps","text":"<ul> <li>Configure rag2f with Spock</li> <li>Build a plugin and register it via entry points</li> <li>Implement a repository plugin using XFiles protocols</li> </ul>"},{"location":"rag2f/repositories/","title":"Repositories (XFiles)","text":"<p>XFiles is rag2f\u2019s registry for heterogeneous repositories: SQL, vector databases, document stores, graphs, or hybrids.</p> <p>rag2f intentionally does not flatten every backend into a lowest-common-denominator API. Instead, it defines minimal contracts and lets repositories opt into richer protocols.</p> <p>\"The truth is out there.\" - The X-Files</p> <pre><code>  \\  |  /\n   .-*-.\n  /  |  \\   XFiles\n</code></pre>"},{"location":"rag2f/repositories/#repository-protocols","title":"Repository protocols","text":"<p>A repository plugin implements one or more of these contracts:</p> <ul> <li>BaseRepository: minimal CRUD + capabilities + native escape hatch</li> <li>QueryableRepository: <code>find()</code> with <code>QuerySpec</code></li> <li>VectorSearchRepository: <code>vector_search()</code> for embedding retrieval</li> <li>GraphTraversalRepository: <code>traverse()</code> for graph queries</li> </ul> <p>Use capabilities to determine what you can safely call.</p>"},{"location":"rag2f/repositories/#capabilities","title":"Capabilities","text":"<p>Repositories declare capabilities (e.g. supports vector search, supports graph traversal). XFiles validates that the repository methods match the declared capabilities.</p> <p>This makes it harder to: - accidentally call vector search on a SQL-only repo, - ship a plugin that claims features it doesn\u2019t implement.</p>"},{"location":"rag2f/repositories/#capability-driven-calling","title":"Capability-driven calling","text":"<p>Before calling advanced methods, check capabilities or guard in your app:</p> <pre><code>result = xfiles.execute_get(\"users_db\")\nif result.is_ok() and result.repository:\n    repo = result.repository\n    if repo.capabilities.get(\"vector_search\"):\n        repo.vector_search(...)\n</code></pre> <p>Example capability declaration (conceptual):</p> <pre><code>capabilities = {\n    \"queryable\": True,\n    \"vector_search\": False,\n    \"graph_traversal\": False,\n}\n</code></pre>"},{"location":"rag2f/repositories/#queryspec","title":"QuerySpec","text":"<p>Queryable repositories accept a <code>QuerySpec</code> structure to express filters, pagination and projection. The exact shape lives in <code>rag2f.core.xfiles.types</code>, but conceptually:</p> <pre><code>from rag2f.core.xfiles import QuerySpec, eq, and_\n\nquery = QuerySpec(\n    select=[\"id\", \"email\"],\n    where=and_(eq(\"status\", \"active\"), eq(\"tier\", \"pro\")),\n    order_by=[\"-created_at\"],\n    limit=10,\n)\nrows = repo.find(query)\n</code></pre>"},{"location":"rag2f/repositories/#minimal-repository-shape","title":"Minimal repository shape","text":"<p>At minimum, a repository should provide:</p> <ul> <li><code>insert(data)</code> to add items</li> <li><code>get(id)</code> to retrieve by identifier</li> <li><code>update(id, data)</code> to modify</li> <li><code>delete(id)</code> to remove</li> <li><code>capabilities()</code> or <code>capabilities</code> metadata</li> </ul> <p>If you implement richer protocols, document the expected payloads in your plugin README.</p>"},{"location":"rag2f/repositories/#native-access","title":"Native access","text":"<p>For advanced use, repositories can expose native handles:</p> <pre><code>client = repo.native(\"primary\")\n# now you're in backend-specific territory\n</code></pre> <p>This \u201cescape hatch\u201d is deliberate: - rag2f keeps contracts minimal, - you can still use vendor-specific power when you want it.</p>"},{"location":"rag2f/repositories/#registering-repositories","title":"Registering repositories","text":"<p>Repository registration is typically performed by plugins via XFiles hooks or explicit registration calls (depending on your plugin design). Registration uses the Result pattern, so check the returned <code>RegisterResult</code> instead of catching exceptions.</p> <p>See Architecture for how XFiles sits in the overall system.</p>"},{"location":"rag2f/repositories/#repository-metadata","title":"Repository metadata","text":"<p>Use metadata to help your app select the right backend:</p> <pre><code>users_result = xfiles.execute_register(\n    \"users_db\",\n    users_repo,\n    meta={\"type\": \"postgresql\", \"domain\": \"users\"},\n)\nif users_result.is_error():\n    raise ValueError(users_result.detail.message)\n\npapers_result = xfiles.execute_register(\n    \"papers\",\n    papers_repo,\n    meta={\"type\": \"vector\", \"domain\": \"research\"},\n)\nif papers_result.is_error():\n    raise ValueError(papers_result.detail.message)\n</code></pre> <p>Metadata is not enforced by the core, but it provides a stable filter surface for your application.</p>"},{"location":"rag2f/result-pattern/","title":"Result Pattern","text":"<p>RAG2F uses a typed Result pattern for common, expected outcomes. Instead of raising exceptions for cases like empty input or missing repositories, methods return a structured Result object with status and details. Exceptions are reserved for system errors (backend crashes, timeouts, invariant violations).</p>"},{"location":"rag2f/result-pattern/#core-types","title":"Core types","text":"<ul> <li><code>BaseResult</code>: shared fields (<code>status</code>, <code>detail</code>) and helpers (<code>is_ok()</code>, <code>is_error()</code>).</li> <li><code>StatusDetail</code>: structured status info (<code>code</code>, <code>message</code>, <code>context</code>).</li> <li><code>StatusCode</code>: centralized status code constants.</li> </ul>"},{"location":"rag2f/result-pattern/#module-specific-results","title":"Module-specific results","text":""},{"location":"rag2f/result-pattern/#johnny5-input","title":"Johnny5 (input)","text":"<ul> <li><code>execute_handle_text_foreground(text) -&gt; InsertResult</code></li> <li>Expected states return <code>InsertResult</code> with <code>status=\"error\"</code> and <code>detail</code>:</li> <li><code>StatusCode.EMPTY</code>: empty input</li> <li><code>StatusCode.DUPLICATE</code>: duplicate input</li> <li><code>StatusCode.NOT_HANDLED</code>: no hook handled the input</li> </ul> <pre><code>result = rag2f.johnny5.execute_handle_text_foreground(text)\nif result.is_ok():\n    use_track_id(result.track_id)\nelse:\n    logger.info(\"Input rejected: %s\", result.detail.code)\n</code></pre>"},{"location":"rag2f/result-pattern/#indianajones-retrievesearch","title":"IndianaJones (retrieve/search)","text":"<ul> <li><code>execute_retrieve(query, k=10) -&gt; RetrieveResult</code></li> <li><code>execute_search(query, k=10, return_mode=...) -&gt; SearchResult</code></li> <li>Expected states return <code>status=\"error\"</code> with <code>detail</code>:</li> <li><code>StatusCode.EMPTY</code>: empty query</li> </ul> <pre><code>result = rag2f.indiana_jones.execute_search(\"docs\", k=5)\nif result.is_ok():\n    print(result.response)\nelse:\n    handle_empty_query()\n</code></pre>"},{"location":"rag2f/result-pattern/#xfiles-repositories","title":"XFiles (repositories)","text":"<ul> <li><code>execute_register(id, repo, meta=None) -&gt; RegisterResult</code></li> <li><code>execute_get(id) -&gt; GetResult</code></li> <li><code>execute_search(...) -&gt; SearchRepoResult</code></li> <li><code>CacheResult</code> is used for explicit cache lookups.</li> </ul> <pre><code>reg = rag2f.xfiles.execute_register(\"primary\", repo, meta={\"type\": \"vector\"})\nif reg.is_ok() and reg.created:\n    logger.info(\"Repository registered: %s\", reg.id)\nelif reg.is_error():\n    raise ValueError(reg.detail.message)\n\nget_result = rag2f.xfiles.execute_get(\"primary\")\nif get_result.is_ok() and get_result.repository:\n    repo = get_result.repository\nelse:\n    handle_missing_repo(get_result.detail)\n</code></pre>"},{"location":"rag2f/result-pattern/#status-codes-high-level","title":"Status codes (high-level)","text":"<ul> <li>Common: <code>EMPTY</code>, <code>INVALID</code>, <code>NOT_FOUND</code>, <code>PARTIAL</code></li> <li>Johnny5: <code>DUPLICATE</code>, <code>DUPLICATE_MERGED</code>, <code>NOT_HANDLED</code></li> <li>IndianaJones: <code>NO_RESULTS</code>, <code>DEGRADED</code></li> <li>XFiles: <code>CACHE_MISS</code>, <code>ALREADY_EXISTS</code>, <code>INVALID_SPEC</code>, <code>PARTIAL_RESULTS</code></li> </ul> <p>Use <code>StatusCode</code> constants instead of string literals to keep checks consistent.</p>"},{"location":"rag2f/troubleshooting/","title":"Troubleshooting","text":"<p>Common issues and how to resolve them.</p>"},{"location":"rag2f/troubleshooting/#plugin-not-discovered","title":"Plugin not discovered","text":"<ul> <li>Verify the folder is under <code>plugins/</code> or you passed <code>plugins_folder</code> to <code>RAG2F.create(...)</code>.</li> <li>Ensure <code>plugin.json</code> exists and points to a valid module file.</li> <li>If using entry points, confirm the entry point returns the plugin folder, not <code>site-packages</code>.</li> </ul>"},{"location":"rag2f/troubleshooting/#hooks-not-running","title":"Hooks not running","text":"<ul> <li>Confirm the hook name matches exactly (case-sensitive).</li> <li>Ensure the hook function is decorated with <code>@hook</code>.</li> <li>Verify the plugin was activated (check logs at startup).</li> </ul>"},{"location":"rag2f/troubleshooting/#no-default-embedder","title":"\u201cNo default embedder\u201d","text":"<ul> <li>Register at least one embedder via a plugin.</li> <li>Set <code>rag2f.embedder_default</code> in config.</li> <li>Avoid registering embedders with the same name.</li> </ul>"},{"location":"rag2f/troubleshooting/#multiple-embedders-but-no-default-configured","title":"\u201cMultiple embedders but no default configured\u201d","text":"<ul> <li>Set <code>rag2f.embedder_default</code> to one of the registered keys.</li> <li>If only one embedder should exist, remove the extra plugin.</li> </ul>"},{"location":"rag2f/troubleshooting/#capability-mismatch-errors","title":"Capability mismatch errors","text":"<ul> <li>Ensure your repository advertises only the capabilities it implements.</li> <li>Implement the required methods before declaring a capability.</li> </ul>"},{"location":"rag2f/troubleshooting/#config-values-not-found","title":"Config values not found","text":"<ul> <li>Check that <code>config_path</code> points to the correct file.</li> <li>Validate <code>plugins.&lt;plugin_id&gt;</code> matches the <code>id</code> in <code>plugin.json</code>.</li> <li>Confirm environment variable overrides are set in the runtime environment.</li> </ul>"},{"location":"rag2f/troubleshooting/#environment-overrides-not-applying","title":"Environment overrides not applying","text":"<ul> <li>Check prefix and section: <code>RAG2F__RAG2F__...</code> or <code>RAG2F__PLUGINS__...</code></li> <li>Ensure values parse correctly (JSON vs string).</li> <li>Remember env overrides config file values.</li> </ul>"},{"location":"rag2f/troubleshooting/#plugin-override-confusion","title":"Plugin override confusion","text":"<p>Entry point plugins take precedence over local plugins with the same id. If you are iterating locally, uninstall the packaged plugin or change the plugin id.</p>"},{"location":"rag2f/troubleshooting/#duplicate-hooks-running-twice","title":"Duplicate hooks running twice","text":"<ul> <li>Confirm you do not have both an entry-point and filesystem plugin with the same id.</li> <li>Ensure your plugin module is not imported twice in different paths.</li> </ul>"},{"location":"rag2f/troubleshooting/#registry-lookup-failures","title":"Registry lookup failures","text":"<ul> <li>Check the registry key casing; keys are treated as strings.</li> <li>Call <code>list_keys()</code> on OptimusPrime/XFiles to verify registration.</li> </ul>"},{"location":"rag2f/troubleshooting/#runtime-errors-inside-hooks","title":"Runtime errors inside hooks","text":"<ul> <li>Reduce hook scope and move heavy logic into helpers.</li> <li>Add logging inside hooks for payload inspection.</li> <li>Use try/except with meaningful error messages for easier debugging.</li> </ul>"}]}